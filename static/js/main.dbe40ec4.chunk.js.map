{"version":3,"sources":["components/Point.js","components/Points.js","js/webglUtils.js","js/gradientRenderer.js","components/Canvas.js","App.js","reportWebVitals.js","index.js"],"names":["Point","colour","points","onChangeColor","index","hex","styles","reactCSS","default","container","left","currentXY","x","top","y","pointContainer","display","justifyContent","alignItems","height","width","flexWrap","point","backgroundColor","picker","pointRef","useRef","containerRef","className","style","ref","id","showPicker","position","color","onChange","disableAlpha","presetColors","defaultProps","Points","onRender","useEffect","i","push","WebGLDebugUtil","require","error","msg","console","log","errorRE","addLineNumbersWithError","src","matches","matchAll","lineNoToErrorMap","Map","map","m","ndx","lineNo","parseInt","next","end","length","substring","split","line","err","get","join","loadShader","gl","shaderSource","shaderType","opt_errorCallback","errFn","shader","createShader","compileShader","getShaderParameter","COMPILE_STATUS","lastError","getShaderInfoLog","deleteShader","createProgram","shaders","opt_attribs","opt_locations","program","forEach","attachShader","attrib","bindAttribLocation","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","getShaderSource","type","SHADER_TYPE","glEnumToString","deleteProgram","defaultShaderType","createProgramFromSources","shaderSources","ii","renderGradient","canvas","getContext","offsetWidth","offsetHeight","locations","getAttribLocation","resolution","getUniformLocation","pointsXY","pointsRGB","pointsHSV","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","positions","bufferData","Float32Array","STATIC_DRAW","vao","createVertexArray","bindVertexArray","enableVertexAttribArray","FLOAT","offset","vertexAttribPointer","multiplier","clientWidth","clientHeight","resizeCanvasToDisplaySize","viewport","useProgram","rgb","r","g","b","hsv","h","s","v","uniform2iv","flat","uniform3fv","uniform2f","primType","TRIANGLES","count","drawArrays","worker","window","Worker","Canvas","canvasPoints","useState","setPoints","draw","imageData","current","putImageData","requestAnimationFrame","shootPixel","t0","Date","now","t1","createImageData","imDataLength","data","terminate","postMessage","onerror","onmessage","e","alert","App","mouseDown","start","mouseBound","setMouseBound","rgbToHslHsvHex","M","C","hue","V","L","rgbArr","Math","max","min","a","hsl","abs","l","colorcode","floor","toString","repeat","defaultColour","random","active","pointerOffset","size","dragIs","setDragIs","hsvRgbObjToArr","obj","arr","setCanvasPoints","dragStart","target","document","elementFromPoint","clientX","clientY","classList","contains","clientXY","substr","touches","add","zIndex","closePickers","remove","parentNode","isAnyActive","onPicker","state","isClick","startXY","endXY","sqrt","pow","set","Array","colourArr","getCanvasPoints","onPointerDown","onPointerMove","preventDefault","boundXY","drag","onPointerUp","dragEnd","update","newDragIs","onClick","newDragItem","splice","removeDragItem","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.dbe40ec4.chunk.js","sourcesContent":["import React from \"react\";\r\nimport reactCSS from \"reactcss\";\r\nimport { useRef, useEffect, useState } from \"react\";\r\nimport { SketchPicker } from \"react-color\";\r\n\r\nconst Point = ({ points, onChangeColor, index }) => {\r\n    var colour;\r\n    if (points[index].colour.hex) {\r\n        colour = points[index].colour.hex;\r\n    } else {\r\n        colour = points[index].colour;\r\n    }\r\n    const styles = reactCSS({\r\n        default: {\r\n            container: {\r\n                left: points[index].currentXY.x,\r\n                top: points[index].currentXY.y,\r\n            },\r\n            pointContainer: {\r\n                display: \"flex\",\r\n                justifyContent: \"center\",\r\n                alignItems: \"center\",\r\n                height: \"36px\",\r\n                width: \"36px\",\r\n                flexWrap: \"nowrap\",\r\n            },\r\n            point: {\r\n                backgroundColor: colour,\r\n            },\r\n            picker: {},\r\n        },\r\n    });\r\n    points[index].pointRef = useRef();\r\n    points[index].containerRef = useRef();\r\n    return (\r\n        <div\r\n            className=\"dragIContainer\"\r\n            style={styles.container}\r\n            ref={points[index].containerRef}\r\n        >\r\n            {/* point container */}\r\n            <div style={styles.pointContainer}>\r\n                <div\r\n                    ref={points[index].pointRef}\r\n                    style={styles.point}\r\n                    className=\"dragItem\"\r\n                    id={points[index].id}\r\n                />\r\n            </div>\r\n            {/* Color picker */}\r\n            {points[index].showPicker && (\r\n                <SketchPicker\r\n                    style={{\r\n                        position: \"fixed\",\r\n                    }}\r\n                    color={colour}\r\n                    onChange={(color) => onChangeColor(index, color)}\r\n                    disableAlpha={true}\r\n                    presetColors={[]}\r\n                />\r\n            )}\r\n        </div>\r\n    );\r\n};\r\nPoint.defaultProps = {\r\n    className: \"dragItem\",\r\n};\r\n\r\nexport default Point;\r\n","import React from \"react\";\r\nimport Point from \"./Point\";\r\nimport { useEffect } from \"react\";\r\n\r\nconst Points = ({ points, onChangeColor, onRender }) => {\r\n    useEffect(() => {\r\n        onRender();\r\n    });\r\n    var Points = [];\r\n    for (let i in points) {\r\n        Points.push(\r\n            <Point points={points} index={i} onChangeColor={onChangeColor} />\r\n        );\r\n    }\r\n    return Points;\r\n};\r\n\r\nexport default Points;\r\n","/*\r\n * Copyright 2021, GFXFundamentals.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are\r\n * met:\r\n *\r\n *     * Redistributions of source code must retain the above copyright\r\n * notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above\r\n * copyright notice, this list of conditions and the following disclaimer\r\n * in the documentation and/or other materials provided with the\r\n * distribution.\r\n *     * Neither the name of GFXFundamentals. nor the names of his\r\n * contributors may be used to endorse or promote products derived from\r\n * this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nvar WebGLDebugUtil = require(\"webgl-debug\");\r\n\r\n/* global define */\r\n\r\n/**\r\n * Wrapped logging function.\r\n * @param {string} msg The message to log.\r\n */\r\nfunction error(msg) {\r\n    if (console) {\r\n        if (console.error) {\r\n            console.error(msg);\r\n        } else if (console.log) {\r\n            console.log(msg);\r\n        }\r\n    }\r\n}\r\n\r\nconst errorRE = /ERROR:\\s*\\d+:(\\d+)/gi;\r\nfunction addLineNumbersWithError(src, log = \"\") {\r\n    // Note: Error message formats are not defined by any spec so this may or may not work.\r\n    const matches = [...log.matchAll(errorRE)];\r\n    const lineNoToErrorMap = new Map(\r\n        matches.map((m, ndx) => {\r\n            const lineNo = parseInt(m[1]);\r\n            const next = matches[ndx + 1];\r\n            const end = next ? next.index : log.length;\r\n            const msg = log.substring(m.index, end);\r\n            return [lineNo - 1, msg];\r\n        })\r\n    );\r\n    return src\r\n        .split(\"\\n\")\r\n        .map((line, lineNo) => {\r\n            const err = lineNoToErrorMap.get(lineNo);\r\n            return `${lineNo + 1}: ${line}${err ? `\\n\\n^^^ ${err}` : \"\"}`;\r\n        })\r\n        .join(\"\\n\");\r\n}\r\n\r\n/**\r\n * Error Callback\r\n * @callback ErrorCallback\r\n * @param {string} msg error message.\r\n * @memberOf module:webgl-utils\r\n */\r\n\r\n/**\r\n * Loads a shader.\r\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\r\n * @param {string} shaderSource The shader source.\r\n * @param {number} shaderType The type of shader.\r\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\r\n * @return {WebGLShader} The created shader.\r\n */\r\nfunction loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\r\n    const errFn = opt_errorCallback || error;\r\n    // Create the shader object\r\n    const shader = gl.createShader(shaderType);\r\n\r\n    // Load the shader source\r\n    gl.shaderSource(shader, shaderSource);\r\n\r\n    // Compile the shader\r\n    gl.compileShader(shader);\r\n\r\n    // Check the compile status\r\n    const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (!compiled) {\r\n        // Something went wrong during compilation; get the error\r\n        const lastError = gl.getShaderInfoLog(shader);\r\n        errFn(\r\n            `Error compiling shader: ${lastError}\\n${addLineNumbersWithError(\r\n                shaderSource,\r\n                lastError\r\n            )}`\r\n        );\r\n        gl.deleteShader(shader);\r\n        return null;\r\n    }\r\n\r\n    return shader;\r\n}\r\n\r\n/**\r\n * Creates a program, attaches shaders, binds attrib locations, links the\r\n * program and calls useProgram.\r\n * @param {WebGLShader[]} shaders The shaders to attach\r\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\r\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\r\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\r\n *        on error. If you want something else pass an callback. It's passed an error message.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction createProgram(\r\n    gl,\r\n    shaders,\r\n    opt_attribs,\r\n    opt_locations,\r\n    opt_errorCallback\r\n) {\r\n    const errFn = opt_errorCallback || error;\r\n    const program = gl.createProgram();\r\n    shaders.forEach(function (shader) {\r\n        gl.attachShader(program, shader);\r\n    });\r\n    if (opt_attribs) {\r\n        opt_attribs.forEach(function (attrib, ndx) {\r\n            gl.bindAttribLocation(\r\n                program,\r\n                opt_locations ? opt_locations[ndx] : ndx,\r\n                attrib\r\n            );\r\n        });\r\n    }\r\n    gl.linkProgram(program);\r\n\r\n    // Check the link status\r\n    const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (!linked) {\r\n        // something went wrong with the link\r\n        const lastError = gl.getProgramInfoLog(program);\r\n        errFn(\r\n            `Error in program linking: ${lastError}\\n${shaders\r\n                .map((shader) => {\r\n                    const src = addLineNumbersWithError(\r\n                        gl.getShaderSource(shader)\r\n                    );\r\n                    const type = gl.getShaderParameter(shader, gl.SHADER_TYPE);\r\n                    return `${WebGLDebugUtil.glEnumToString(\r\n                        gl,\r\n                        type\r\n                    )}:\\n${src}`;\r\n                })\r\n                .join(\"\\n\")}`\r\n        );\r\n\r\n        gl.deleteProgram(program);\r\n        return null;\r\n    }\r\n    return program;\r\n}\r\n\r\n/**\r\n * Loads a shader from a script tag.\r\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\r\n * @param {string} scriptId The id of the script tag.\r\n * @param {number} opt_shaderType The type of shader. If not passed in it will\r\n *     be derived from the type of the script tag.\r\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\r\n * @return {WebGLShader} The created shader.\r\n */\r\nfunction createShaderFromScript(\r\n    gl,\r\n    scriptId,\r\n    opt_shaderType,\r\n    opt_errorCallback\r\n) {\r\n    let shaderSource = \"\";\r\n    let shaderType;\r\n    const shaderScript = document.getElementById(scriptId);\r\n    if (!shaderScript) {\r\n        throw \"*** Error: unknown script element\" + scriptId;\r\n    }\r\n    shaderSource = shaderScript.text;\r\n\r\n    if (!opt_shaderType) {\r\n        if (shaderScript.type === \"x-shader/x-vertex\") {\r\n            shaderType = gl.VERTEX_SHADER;\r\n        } else if (shaderScript.type === \"x-shader/x-fragment\") {\r\n            shaderType = gl.FRAGMENT_SHADER;\r\n        } else if (\r\n            shaderType !== gl.VERTEX_SHADER &&\r\n            shaderType !== gl.FRAGMENT_SHADER\r\n        ) {\r\n            throw \"*** Error: unknown shader type\";\r\n        }\r\n    }\r\n\r\n    return loadShader(\r\n        gl,\r\n        shaderSource,\r\n        opt_shaderType ? opt_shaderType : shaderType,\r\n        opt_errorCallback\r\n    );\r\n}\r\n\r\nconst defaultShaderType = [\"VERTEX_SHADER\", \"FRAGMENT_SHADER\"];\r\n\r\n/**\r\n * Creates a program from 2 script tags.\r\n *\r\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext\r\n *        to use.\r\n * @param {string[]} shaderScriptIds Array of ids of the script\r\n *        tags for the shaders. The first is assumed to be the\r\n *        vertex shader, the second the fragment shader.\r\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\r\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\r\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\r\n *        on error. If you want something else pass an callback. It's passed an error message.\r\n * @return {WebGLProgram} The created program.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction createProgramFromScripts(\r\n    gl,\r\n    shaderScriptIds,\r\n    opt_attribs,\r\n    opt_locations,\r\n    opt_errorCallback\r\n) {\r\n    const shaders = [];\r\n    for (let ii = 0; ii < shaderScriptIds.length; ++ii) {\r\n        shaders.push(\r\n            createShaderFromScript(\r\n                gl,\r\n                shaderScriptIds[ii],\r\n                gl[defaultShaderType[ii]],\r\n                opt_errorCallback\r\n            )\r\n        );\r\n    }\r\n    return createProgram(\r\n        gl,\r\n        shaders,\r\n        opt_attribs,\r\n        opt_locations,\r\n        opt_errorCallback\r\n    );\r\n}\r\n\r\n/**\r\n * Creates a program from 2 sources.\r\n *\r\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext\r\n *        to use.\r\n * @param {string[]} shaderSourcess Array of sources for the\r\n *        shaders. The first is assumed to be the vertex shader,\r\n *        the second the fragment shader.\r\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\r\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\r\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\r\n *        on error. If you want something else pass an callback. It's passed an error message.\r\n * @return {WebGLProgram} The created program.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction createProgramFromSources(\r\n    gl,\r\n    shaderSources,\r\n    opt_attribs,\r\n    opt_locations,\r\n    opt_errorCallback\r\n) {\r\n    const shaders = [];\r\n    for (let ii = 0; ii < shaderSources.length; ++ii) {\r\n        shaders.push(\r\n            loadShader(\r\n                gl,\r\n                shaderSources[ii],\r\n                gl[defaultShaderType[ii]],\r\n                opt_errorCallback\r\n            )\r\n        );\r\n    }\r\n    console.log({ shaderSources, shaders });\r\n    return createProgram(\r\n        gl,\r\n        shaders,\r\n        opt_attribs,\r\n        opt_locations,\r\n        opt_errorCallback\r\n    );\r\n}\r\n\r\n/**\r\n * Resize a canvas to match the size its displayed.\r\n * @param {HTMLCanvasElement} canvas The canvas to resize.\r\n * @param {number} [multiplier] amount to multiply by.\r\n *    Pass in window.devicePixelRatio for native pixels.\r\n * @return {boolean} true if the canvas was resized.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction resizeCanvasToDisplaySize(canvas, multiplier) {\r\n    multiplier = multiplier || 1;\r\n    const width = (canvas.clientWidth * multiplier) | 0;\r\n    const height = (canvas.clientHeight * multiplier) | 0;\r\n    if (canvas.width !== width || canvas.height !== height) {\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport { resizeCanvasToDisplaySize };\r\nexport default createProgramFromSources;\r\n","// importing boilerplate functions\r\nimport createProgramFromSources, {\r\n    resizeCanvasToDisplaySize,\r\n} from \"../js/webglUtils\";\r\n\r\n// vertex shader function that is just a function to accompany the fragment shader\r\nconst getVertexShader = () => {\r\n    const vs = `#version 300 es\r\n    in vec2 a_position;\r\n\r\n    uniform vec2 u_resolution;\r\n\r\n    out vec2 v_position;\r\n\r\n    void main(){\r\n        gl_Position = vec4(a_position/u_resolution * 2.0 - 1.0, 0, 1);\r\n        v_position = vec2(a_position.x, u_resolution.y-a_position.y);\r\n    }\r\n    `;\r\n    return vs;\r\n};\r\n\r\n// fragment shader function that returns FS with the number of points embedded in the source (length)\r\nconst getFragmentShader = (length) => {\r\n    const fs = `#version 300 es\r\n    precision highp float;\r\n\r\n    in vec2 v_position;\r\n\r\n    uniform vec2 u_resolution;\r\n    uniform ivec2 pointsXY[${length}];\r\n    uniform vec3 pointsRGB[${length}];\r\n    uniform vec3 pointsHSV[${length}];\r\n\r\n    out vec4 outColor;\r\n\r\n    vec2 minMax(vec3 rgb){\r\n        vec2 mM = vec2(rgb[0], rgb[0]);\r\n        for(int i=1;i<3;i++){\r\n            if (rgb[i] < mM[0])\r\n                mM[0] = rgb[i];\r\n            if (rgb[i] > mM[1])\r\n                mM[1] = rgb[i];\r\n        }\r\n        return mM;\r\n    }\r\n\r\n    float rgbToHue(vec3 rgb){\r\n        float hue=0.0, C;\r\n        vec2 mM = minMax(rgb);\r\n        C = mM[1] - mM[0];\r\n        if(C==0.0){\r\n        }else if(mM[1]==rgb[0]){\r\n            hue = mod((rgb[1] - rgb[2]) / C, 6.0);\r\n        }else if(mM[1]==rgb[1]){\r\n            hue =     (rgb[2] - rgb[0]) / C + 2.0;\r\n        }else if(mM[1]==rgb[2]){\r\n            hue =     (rgb[0] - rgb[1]) / C + 4.0;\r\n        }\r\n        hue = mod((mod(hue * 60.0, 360.0) + 360.0), 360.0);\r\n        return hue;\r\n    }\r\n\r\n    float f(int n, vec3 hsv){\r\n        float k;\r\n        k = mod((float(n) + hsv[0] / 60.0), 6.0);\r\n        float fOut=hsv[2] - hsv[2] * hsv[1] * max(0.0, min(min(k, 4.0 - k), 1.0));\r\n        return fOut;\r\n    }\r\n\r\n    vec3 hsvToRgb(vec3 hsv){\r\n        vec3 rgb = vec3(f(5,hsv), f(3,hsv), f(1,hsv));\r\n        return rgb;\r\n    }\r\n\r\n    float dist(ivec2 pos, ivec2 point){\r\n        return pow(pow(float(pos.x-point.x), 2.0)+pow(float(pos.y-point.y), 2.0), 0.5);\r\n    }\r\n\r\n    void main(){\r\n        // ivec2 position = ivec2((v_position + 1.0) / 2.0 * u_resolution);\r\n        ivec2 position = ivec2(v_position);\r\n        float invSum = 0.0;\r\n        vec3 hsv = vec3(0,0,0), rgb = vec3(0,0,0);\r\n        for(int i=0;i<${length};i++){\r\n            float invD = 1.0/dist(pointsXY[i], position);\r\n            hsv += invD * pointsHSV[i];\r\n            rgb += invD * pointsRGB[i];\r\n            invSum += invD;\r\n        }\r\n        hsv = hsv/invSum;\r\n        rgb = rgb/invSum;\r\n        hsv[0] = rgbToHue(rgb);\r\n        // vec3 outPut = hsv2rgb(hsv);\r\n        // outColor = hsvToRgb(hsv);\r\n        outColor = vec4(hsvToRgb(hsv),1);\r\n        // outColor = vec4(rgb,1);\r\n        // outColor = hsv;\r\n        // outColor = pointsRGB[0];\r\n    }\r\n\r\n    `;\r\n    return fs;\r\n};\r\n\r\nconst renderGradient = (points, canvas) => {\r\n    if (points && points.length > 0) {\r\n        // accessing WebGL2 context from canvas\r\n        const gl = canvas.getContext(\"webgl2\");\r\n\r\n        // resizing canvas context to canvas width set by CSS\r\n        canvas.width = canvas.offsetWidth;\r\n        canvas.height = canvas.offsetHeight;\r\n\r\n        // creating program using the vs and fs functions above\r\n        const program = createProgramFromSources(gl, [\r\n            getVertexShader(),\r\n            getFragmentShader(points.length),\r\n        ]);\r\n\r\n        // storing locations of attributes and uniforms (state variables)\r\n        const locations = {\r\n            position: gl.getAttribLocation(program, \"a_position\"),\r\n            resolution: gl.getUniformLocation(program, \"u_resolution\"),\r\n            pointsXY: gl.getUniformLocation(program, \"pointsXY\"),\r\n            pointsRGB: gl.getUniformLocation(program, \"pointsRGB\"),\r\n            pointsHSV: gl.getUniformLocation(program, \"pointsHSV\"),\r\n        };\r\n\r\n        // creating a position buffer to load the entire clipspace into webgl buffer\r\n        var positionBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n        // clipspace is formed using two (anticlockwise) triangles\r\n        // prettier-ignore\r\n        var positions = [\r\n                   0, canvas.height, \r\n        canvas.width, 0, \r\n        canvas.width, canvas.height, \r\n                   0, 0, \r\n        canvas.width, 0, \r\n                   0, canvas.height\r\n    ];\r\n        // loading positions array to graphics buffer\r\n        gl.bufferData(\r\n            gl.ARRAY_BUFFER,\r\n            new Float32Array(positions),\r\n            gl.STATIC_DRAW\r\n        );\r\n\r\n        // creating vertex array object that will attach the positionBuffer to the attributes\r\n        var vao = gl.createVertexArray();\r\n        // binding current vertex array to vao\r\n        gl.bindVertexArray(vao);\r\n        // connecting vao to a_position attribute\r\n        gl.enableVertexAttribArray(locations.position);\r\n        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n        var size = 2; // 2 components per iteration (x, y)\r\n        var type = gl.FLOAT; // the data is 32bit floats\r\n        var normalize = false; // don't normalize the data\r\n        var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position (consecutive elemets)\r\n        var offset = 0; // start at the beginning of the buffer\r\n        // attach vao to the current ARRAY_BUFFER (positionBuffer) and pass instructions on how to interpret the data\r\n        gl.vertexAttribPointer(\r\n            locations.position,\r\n            size,\r\n            type,\r\n            normalize,\r\n            stride,\r\n            offset\r\n        );\r\n\r\n        // resizing canvas to fit the fill clipspace - not sure why since we already did canvas.width = offsetWidth and all...\r\n        resizeCanvasToDisplaySize(gl.canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n        // Telling WebGL to use our program (with the pair of shaders)\r\n        gl.useProgram(program);\r\n\r\n        // generating arrays that will be sent to uniforms\r\n        const pointsXY = points.map(({ x, y }) => {\r\n            return [x, y];\r\n        });\r\n        const pointsRGB = points.map(({ colour }) => {\r\n            return [colour.rgb.r / 255, colour.rgb.g / 255, colour.rgb.b / 255];\r\n        });\r\n        const pointsHSV = points.map(({ colour }) => {\r\n            return [colour.hsv.h / 360, colour.hsv.s, colour.hsv.v];\r\n        });\r\n        // setting uniforms\r\n        gl.uniform2iv(locations.pointsXY, pointsXY.flat());\r\n        gl.uniform3fv(locations.pointsRGB, pointsRGB.flat());\r\n        gl.uniform3fv(locations.pointsHSV, pointsHSV.flat());\r\n        gl.uniform2f(locations.resolution, canvas.width, canvas.height);\r\n\r\n        // drawwwww\r\n        var primType = gl.TRIANGLES;\r\n        var offset = 0;\r\n        var count = positions.length / size;\r\n        gl.drawArrays(primType, offset, count);\r\n\r\n        return true;\r\n\r\n        // simply reading the data\r\n        // var results = new Uint8Array(canvas.width * canvas.height * 4);\r\n        // gl.readPixels(\r\n        //     0,\r\n        //     0,\r\n        //     canvas.width,\r\n        //     canvas.height,\r\n        //     gl.RGBA,\r\n        //     gl.UNSIGNED_BYTE,\r\n        //     results\r\n        // );\r\n        // var resultsB = [];\r\n        // for (let i = 0; i < canvas.width * canvas.height; i++) {\r\n        //     resultsB.push({\r\n        //         r: results[4 * i],\r\n        //         g: results[4 * i + 1],\r\n        //         b: results[4 * i + 2],\r\n        //         a: results[4 * i + 3],\r\n        //     });\r\n        // }\r\n        // console.log({ results, resultsB });\r\n    }\r\n};\r\n\r\nexport default renderGradient;\r\n","import React, { useState, useRef, useEffect } from \"react\";\r\nimport renderGradient from \"../js/gradientRenderer\";\r\n\r\nvar worker = new window.Worker(\"./gradientWorker.js\");\r\n\r\nconst Canvas = ({ id, canvasPoints }) => {\r\n    const [points, setPoints] = useState(canvasPoints);\r\n    const [canvas, setCanvas] = useState(useRef(null));\r\n    const draw = (imageData) => {\r\n        var ctx = canvas.current.getContext(\"2d\");\r\n        ctx.putImageData(imageData, 0, 0);\r\n        window.requestAnimationFrame(() => draw(imageData));\r\n    };\r\n    const shootPixel = () => {\r\n        canvas.current.width = canvas.current.offsetWidth;\r\n        canvas.current.height = canvas.current.offsetHeight;\r\n        if (!canvas.current.getContext(\"webgl2\")) {\r\n            var ctx = canvas.current.getContext(\"2d\");\r\n            const imageData = ctx.createImageData(\r\n                canvas.current.width,\r\n                canvas.current.height\r\n            );\r\n            var imDataLength = imageData.data.length;\r\n            // Calling worker\r\n            worker.terminate();\r\n            worker = new window.Worker(\"./gradientWorker.js\");\r\n            worker.postMessage({\r\n                imageData: imageData,\r\n                points: points,\r\n                canvas: {\r\n                    width: canvas.current.width,\r\n                    height: canvas.current.height,\r\n                },\r\n            });\r\n            worker.onerror = (err) => {\r\n                console.log(\"error\", err);\r\n            };\r\n            worker.onmessage = (e) => {\r\n                if (imDataLength === e.data.imageData.data.length) {\r\n                    // var t0 = Date.now();\r\n                    window.requestAnimationFrame(() => draw(e.data.imageData));\r\n                    // var t1 = Date.now() - t0;\r\n                    // console.log(\"drawing time \" + t1 + \"ms\");\r\n                }\r\n            };\r\n        } else {\r\n            var t0 = Date.now();\r\n            renderGradient(points, canvas.current);\r\n            var t1 = Date.now() - t0;\r\n            console.log(\"GPU drawing time \" + t1 + \"ms\");\r\n        }\r\n    };\r\n    useEffect(() => {\r\n        setPoints(canvasPoints);\r\n        shootPixel();\r\n    });\r\n    useEffect(() => {\r\n        if (!canvas.current.getContext(\"webgl2\")) {\r\n            alert(\r\n                \"WebGL not available in this browser/platform. Renders may be slower.\"\r\n            );\r\n        }\r\n    }, []);\r\n    return <canvas id={id} ref={canvas} />;\r\n};\r\n\r\nexport default Canvas;\r\n","import { useState, useEffect } from \"react\";\r\nimport Points from \"./components/Points\";\r\nimport Canvas from \"./components/Canvas\";\r\n\r\nfunction App() {\r\n    const [mouseBound, setMouseBound] = useState([\r\n        {\r\n            mouseDown: false,\r\n            start: {\r\n                x: 0,\r\n                y: 0,\r\n            },\r\n            end: {\r\n                x: 0,\r\n                y: 0,\r\n            },\r\n        },\r\n    ]);\r\n    const rgbToHslHsvHex = (rgb) => {\r\n        var rgbArr = [rgb.r, rgb.g, rgb.b];\r\n        var M, m, C, hue, I, V, L, Sv, Sl;\r\n        M = Math.max(...rgbArr);\r\n        m = Math.min(...rgbArr);\r\n        C = M - m;\r\n        I = (rgbArr[0] + rgbArr[1] + rgbArr[2]) / 3;\r\n        // Hue\r\n        if (C === 0) hue = 0;\r\n        else if (M === rgbArr[0]) hue = ((rgbArr[1] - rgbArr[2]) / C) % 6;\r\n        else if (M === rgbArr[1]) hue = (rgbArr[2] - rgbArr[0]) / C + 2;\r\n        else if (M === rgbArr[2]) hue = (rgbArr[0] - rgbArr[1]) / C + 4;\r\n        hue *= 60;\r\n        // Lightness and Value\r\n        V = M / 255;\r\n        L = (M + m) / (2 * 255);\r\n        // Saturation\r\n        if (V === 0) Sv = 0;\r\n        else Sv = C / (V * 255);\r\n        if (L === 1 || L === 0) Sl = 0;\r\n        else Sl = C / (255 * (1 - Math.abs(2 * L - 1)));\r\n\r\n        hue = ((hue % 360) + 360) % 360;\r\n        // L = (L % 1 + 1)%1\r\n        // V = (V % 1 + 1)%1\r\n        // Sv = (Sv % 1 + 1)%1\r\n        // Sl = (Sl % 1 + 1)%1\r\n        let hsv = { h: hue, s: Sv, v: V, a: 1 };\r\n        let hsl = { h: hue, s: Sl, l: L, a: 1 };\r\n        rgb.a = 1;\r\n        let hex = \"#\";\r\n        for (let i in rgbArr) {\r\n            let colorcode = Math.floor(rgbArr[i]).toString(16);\r\n            hex += \"0\".repeat(2 - colorcode.length) + colorcode;\r\n        }\r\n        return { rgb: rgb, hsv: hsv, hsl: hsl, hex: hex };\r\n    };\r\n    var defaultColour = rgbToHslHsvHex({\r\n        r: Math.random() * 255,\r\n        g: Math.random() * 255,\r\n        b: Math.random() * 255,\r\n    });\r\n    const [dragIs, setDragIs] = useState([\r\n        {\r\n            // While not being dragged, [pointerOffset, currentXY, offset] stores the same value, the X and Y coordinate from the original position (0,0), (used in transform: translate3D(X, Y, 0))\r\n            // While being dragged,\r\n            //      pointerOffset[X, Y] stores the pointerOffset X and Y offset of the pointer to the anchor of dragItem\r\n            //      currentXY[X, Y] stores the total X and Y offsets from the pointerOffset position (0,0).\r\n            // After a drag event, all [pointerOffset, currentXY, offset] stores the same value, the X and Y coordinate from the original position (0,0); again.\r\n            pointRef: null,\r\n            containerRef: null,\r\n            active: false,\r\n            colour: defaultColour,\r\n            showPicker: false,\r\n            pointerOffset: { x: 0, y: 0 },\r\n            currentXY: { x: 50, y: 50 },\r\n            size: false,\r\n        },\r\n    ]);\r\n    const hsvRgbObjToArr = (obj) => {\r\n        var arr = [\r\n            [0, 0, 0],\r\n            [0, 0, 0],\r\n        ];\r\n        arr[0] = [obj.hsv.h, obj.hsv.s, obj.hsv.v];\r\n        arr[1] = [obj.rgb.r, obj.rgb.g, obj.rgb.b];\r\n        return arr;\r\n    };\r\n    const getCanvasPoints = (set) => {\r\n        let points = new Array(dragIs.length);\r\n        for (let i in dragIs) {\r\n            if (dragIs[i].size) {\r\n                points[i] = {\r\n                    x: dragIs[i].currentXY.x + dragIs[i].size[0] / 2,\r\n                    y: dragIs[i].currentXY.y + dragIs[i].size[1] / 2,\r\n                    colour: dragIs[i].colour,\r\n                    colourArr: hsvRgbObjToArr(dragIs[i].colour),\r\n                };\r\n            }\r\n        }\r\n        if (set) setCanvasPoints(points);\r\n        return points;\r\n    };\r\n    const [canvasPoints, setCanvasPoints] = useState(false);\r\n\r\n    const addDragItem = () => {\r\n        var currentXY = { x: 50, y: 50 },\r\n            colour;\r\n        if (dragIs.length > 0) {\r\n            var boundXY = [\r\n                [0, 0],\r\n                [0, 0],\r\n            ];\r\n            boundXY[1] = [\r\n                boundXY[0][0] +\r\n                    dragIs[0].containerRef.current.parentNode.clientWidth -\r\n                    dragIs[0].size[0],\r\n                boundXY[0][1] +\r\n                    dragIs[0].containerRef.current.parentNode.clientHeight -\r\n                    dragIs[0].size[1],\r\n            ];\r\n            let x, y;\r\n            x = Math.floor(Math.random() * boundXY[1][0] + boundXY[0][0]);\r\n            y = Math.floor(Math.random() * boundXY[1][1] + boundXY[0][1]);\r\n            currentXY = { x: x, y: y };\r\n        }\r\n        colour = {\r\n            r: Math.random() * 255,\r\n            g: Math.random() * 255,\r\n            b: Math.random() * 255,\r\n        };\r\n        colour = rgbToHslHsvHex(colour);\r\n        const newDragItem = {\r\n            ref: null,\r\n            containerRef: null,\r\n            active: false,\r\n            colour: colour,\r\n            showPicker: false,\r\n            pointerOffset: { x: 0, y: 0 },\r\n            currentXY: currentXY,\r\n            size: false,\r\n        };\r\n        setDragIs([...dragIs, newDragItem]);\r\n    };\r\n    const removeDragItem = ({ index }) => {\r\n        if (index === -1) {\r\n            index = dragIs.length - 1;\r\n        }\r\n        console.log(\"Removing point with key \" + index);\r\n        let newDragIs = dragIs;\r\n        newDragIs.splice(index, 1);\r\n        setDragIs([...newDragIs]);\r\n        console.log(\"New points are \", dragIs);\r\n    };\r\n    const dragStart = (e) => {\r\n        // mouseDown is to capture off location drags that go over inactive point\r\n        mouseBound.mouseDown = true;\r\n        setMouseBound(mouseBound);\r\n        // capturing target since touch and mouse output different e.target\r\n        var target = document.elementFromPoint(e.clientX, e.clientY);\r\n        if (target.classList.contains(\"dragItem\")) {\r\n            var index;\r\n            for (let i in dragIs) {\r\n                if (dragIs[i].pointRef.current === target) {\r\n                    index = i;\r\n                }\r\n            }\r\n            console.log(\"dragStart \" + index, dragIs[index]);\r\n            let clientXY = { x: 0, y: 0 };\r\n            if (e.type.substr(0, 5) === \"touch\") {\r\n                clientXY = { x: e.touches[0].clientX, y: e.touches[0].clientY };\r\n            } else {\r\n                clientXY = { x: e.clientX, y: e.clientY };\r\n            }\r\n            mouseBound.start = clientXY;\r\n            mouseBound.end = clientXY;\r\n            setMouseBound(mouseBound);\r\n            dragIs[index].pointerOffset.x =\r\n                clientXY.x - dragIs[index].currentXY.x;\r\n            dragIs[index].pointerOffset.y =\r\n                clientXY.y - dragIs[index].currentXY.y;\r\n            dragIs[index].active = true;\r\n            dragIs[index].pointRef.current.classList.add(\"active\");\r\n            dragIs[index].containerRef.current.style.zIndex = 1;\r\n            setDragIs([...dragIs]);\r\n        }\r\n    };\r\n    const drag = (e) => {\r\n        if (isAnyActive()) {\r\n            var index;\r\n            for (let i in dragIs) {\r\n                if (dragIs[i].active) {\r\n                    index = i;\r\n                }\r\n            }\r\n            e.preventDefault();\r\n            // Calculating current XY\r\n            let clientXY = { x: 0, y: 0 };\r\n            if (e.type.substr(0, 5) === \"touch\") {\r\n                clientXY = { x: e.touches[0].clientX, y: e.touches[0].clientY };\r\n            } else {\r\n                clientXY = { x: e.clientX, y: e.clientY };\r\n            }\r\n            mouseBound.end = clientXY;\r\n            var target = document.elementFromPoint(clientXY.x, clientXY.y);\r\n            setMouseBound(mouseBound);\r\n            if (!isClick(mouseBound.start, mouseBound.end)) {\r\n                onPicker(dragIs[index], false);\r\n                closePickers(index);\r\n                var currentXY = { x: 0, y: 0 };\r\n                currentXY.x = clientXY.x - dragIs[index].pointerOffset.x;\r\n                currentXY.y = clientXY.y - dragIs[index].pointerOffset.y;\r\n                let boundXY = [\r\n                    [0, 0],\r\n                    [0, 0],\r\n                ];\r\n                boundXY[1] = [\r\n                    boundXY[0][0] +\r\n                        dragIs[index].containerRef.current.parentNode\r\n                            .clientWidth -\r\n                        dragIs[index].size[0],\r\n                    boundXY[0][1] +\r\n                        dragIs[index].containerRef.current.parentNode\r\n                            .clientHeight -\r\n                        dragIs[index].size[1],\r\n                ];\r\n                dragIs[index].currentXY.x = Math.max(\r\n                    Math.min(currentXY.x, boundXY[1][0]),\r\n                    boundXY[0][0]\r\n                );\r\n                dragIs[index].currentXY.y = Math.max(\r\n                    Math.min(currentXY.y, boundXY[1][1]),\r\n                    boundXY[0][1]\r\n                );\r\n\r\n                setDragIs([...dragIs]);\r\n            }\r\n        } else if (mouseBound.mouseDown) {\r\n            dragStart(e);\r\n        } else {\r\n            // var target = document.elementFromPoint(e.clientX, e.clientY);\r\n            // // console.log(target)\r\n            // try {\r\n            //     if (target.tagName === \"CANVAS\")\r\n            //         console.log(\r\n            //             target\r\n            //                 .getContext(\"2d\")\r\n            //                 .getImageData(e.clientX, e.clientY, 1, 1).data\r\n            //         );\r\n            // } catch {}\r\n        }\r\n    };\r\n    const dragEnd = (e) => {\r\n        mouseBound.mouseDown = false;\r\n        setMouseBound(mouseBound);\r\n        var index;\r\n        for (let i in dragIs) if (dragIs[i].active) index = i;\r\n        if (index) {\r\n            dragIs[index].pointerOffset.x = dragIs[index].currentXY.x;\r\n            dragIs[index].pointerOffset.y = dragIs[index].currentXY.y;\r\n            dragIs[index].active = false;\r\n            if (\r\n                isClick(mouseBound.start, mouseBound.end) &&\r\n                !dragIs[index].showPicker\r\n            ) {\r\n                closePickers(index);\r\n                dragIs[index].pointRef.current.classList.add(\"active\");\r\n                dragIs[index].containerRef.current.style.zIndex = 2;\r\n                onPicker(dragIs[index], true);\r\n            } else {\r\n                dragIs[index].pointRef.current.classList.remove(\"active\");\r\n                onPicker(dragIs[index], false);\r\n                dragIs[index].containerRef.current.style.zIndex = 1;\r\n            }\r\n\r\n            console.log(\"dragEnd \" + index, dragIs[index]);\r\n            setDragIs([...dragIs]);\r\n        }\r\n    };\r\n    const closePickers = (index) => {\r\n        for (let i in dragIs) {\r\n            dragIs[i].showPicker = false;\r\n            dragIs[i].pointRef.current.classList.remove(\"active\");\r\n            dragIs[i].containerRef.current.style.zIndex = 1;\r\n        }\r\n        dragIs[index].pointRef.current.classList.add(\"active\");\r\n        dragIs[index].pointRef.current.parentNode.style.zIndex = 2;\r\n        setDragIs(dragIs);\r\n    };\r\n    const isAnyActive = () => {\r\n        let active = false;\r\n        for (let i in dragIs) {\r\n            active = active || dragIs[i].active;\r\n        }\r\n        return active;\r\n    };\r\n    const isPickerActive = () => {\r\n        let showPicker = false;\r\n        for (let i in dragIs) {\r\n            showPicker = showPicker || dragIs[i].showPicker;\r\n        }\r\n        return showPicker;\r\n    };\r\n    const onPicker = (point, state) => {\r\n        point.showPicker = state;\r\n    };\r\n    const isClick = (startXY, endXY) => {\r\n        let tol = 5;\r\n        let value = Math.sqrt(\r\n            Math.pow(endXY.x - startXY.x, 2) + Math.pow(endXY.y - startXY.y, 2)\r\n        );\r\n        return value <= tol;\r\n    };\r\n    const initSizes = () => {\r\n        let update = false;\r\n        for (let i in dragIs) {\r\n            if (!dragIs[i].size) {\r\n                update = true;\r\n                dragIs[i].size = [\r\n                    dragIs[i].pointRef.current.offsetWidth,\r\n                    dragIs[i].pointRef.current.offsetHeight,\r\n                ];\r\n            }\r\n        }\r\n        if (update) setDragIs(dragIs);\r\n    };\r\n    const onChangeColor = (index, color) => {\r\n        let newDragIs = [...dragIs];\r\n        newDragIs[index].colour = color;\r\n        setDragIs([...newDragIs]);\r\n    };\r\n    useEffect(() => {\r\n        getCanvasPoints(true);\r\n    }, [dragIs]);\r\n\r\n    return (\r\n        <div\r\n            className=\"App\"\r\n            onPointerDown={(e) => dragStart(e)}\r\n            onPointerMove={(e) => drag(e)}\r\n            onPointerUp={(e) => dragEnd(e)}\r\n        >\r\n            <div id=\"outerContainer\">\r\n                <div id=\"dragPalette\">\r\n                    <Canvas\r\n                        id={\"gradientPalette\"}\r\n                        canvasPoints={canvasPoints}\r\n                    />\r\n                </div>\r\n                <Points\r\n                    points={dragIs}\r\n                    onRender={initSizes}\r\n                    onChangeColor={onChangeColor}\r\n                />\r\n                <div id=\"point-manager\">\r\n                    <button\r\n                        className=\"button plus\"\r\n                        onClick={addDragItem}\r\n                    ></button>\r\n                    <button\r\n                        className=\"button minus\"\r\n                        onClick={() => removeDragItem({ index: -1 })}\r\n                    ></button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport './css/style.css';\nimport './css/dragPalette.css';\nimport './css/pointManager.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();"],"sourceRoot":""}