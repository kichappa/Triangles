{"version":3,"sources":["components/Point.js","components/Points.js","components/Canvas.js","App.js","reportWebVitals.js","index.js"],"names":["Point","className","points","onChangeColor","index","styles","reactCSS","container","position","left","currentXY","x","top","y","point","backgroundColor","colour","hex","picker","useEffect","ref","useRef","style","id","showPicker","color","onChange","disableAlpha","presetColors","defaultProps","Points","onRender","i","push","Canvas","canvasPoints","useState","setPoints","canvas","distance","Math","sqrt","pow","getColor","invSum","hsv","d","h","s","v","f","n","k","max","min","hsvToRgb","ctx","current","getContext","width","offsetWidth","height","offsetHeight","imageData","createImageData","count","pixel","data","putImageData","shootPixel","App","mouseDown","start","end","mouseBound","setMouseBound","defaultColour","active","pointerOffset","size","dragIs","setDragIs","setCanvasPoints","dragStart","e","target","document","elementFromPoint","clientX","clientY","classList","contains","console","log","clientXY","type","substr","touches","add","parentNode","zIndex","closePickers","remove","isAnyAcive","onPicker","state","isClick","startXY","endXY","set","Array","length","getCanvasPoints","onPointerDown","onPointerMove","preventDefault","boundXY","clientWidth","clientHeight","drag","onPointerUp","dragEnd","update","newDragIs","onClick","newDragItem","splice","removeDragItem","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.ee62b704.chunk.js","sourcesContent":["import React from 'react'\r\nimport reactCSS from 'reactcss'\r\nimport {useRef, useEffect, useState} from 'react'\r\nimport { SketchPicker } from 'react-color';\r\n\r\nconst Point = ({className, points, onChangeColor, index}) => {\r\n    // console.log(points, points[index])    \r\n    // const [color, setColor] =  useState({\r\n    //     color: points[index].colour.hex, \r\n    //     fullColor: points[index].colour\r\n    // })\r\n    // console.log(color[0])\r\n    const styles = reactCSS({\r\n        'default':{\r\n            container: {\r\n                position: 'absolute',\r\n                left: points[index].currentXY.x,\r\n                top: points[index].currentXY.y,\r\n            },\r\n            point: {\r\n                // backgroundColor: color.color,\r\n                backgroundColor: points[index].colour.hex,\r\n            },\r\n            picker:{\r\n                position: 'fixed'\r\n            }\r\n        },\r\n    })\r\n    // points[index].size = [points[index].ref.current.offsetWidth,points[index].ref.current.offsetHeight]\r\n    useEffect(()=>{\r\n        // setColor(points[index].color)\r\n        // points[index].ref.current.parentNode.style.left = points[index].currentXY.x\r\n        // points[index].ref.current.parentNode.style.top= points[index].currentXY.y\r\n        // console.log(points[index].ref.current.parentNode.style.left, points[index].ref.current.parentNode.style.top)\r\n    })\r\n    const changeColor=(color)=>{\r\n        // console.log(\"tT changing color to\", color, color.hex)\r\n        // onChangeColor(color)\r\n        // points[index].colour = color\r\n        // onChangeColor(index, color)\r\n        // setColor({color: color.hex, fullColor: color})\r\n        // onChangeColor(index, color)\r\n    }\r\n    points[index].ref = useRef(null)\r\n    \r\n    return (\r\n        <div style={styles.container}>\r\n            <div \r\n                ref={points[index].ref} \r\n                style={styles.point} \r\n                className=\"dragItem\" \r\n                id={points[index].id}\r\n                // onClick={onClick(points[index])}\r\n            />\r\n            {points[index].showPicker && \r\n            <SketchPicker\r\n                style={{\r\n                    position: 'fixed'\r\n                }}\r\n                // color={color.color}\r\n                color={points[index].colour.hex}\r\n                // onChange={changeColor}\r\n                onChange={(color)=>onChangeColor(index, color)}\r\n                disableAlpha={true}\r\n                presetColors={[]}\r\n            />}\r\n        </div>\r\n    )\r\n}\r\n\r\nPoint.defaultProps = {\r\n    className: \"dragItem\",\r\n}\r\n\r\nexport default Point\r\n","import React from 'react'\r\nimport Point from \"./Point\"\r\nimport { useEffect } from 'react'\r\n\r\nconst Points = ({points, onChangeColor, onRender}) => {\r\n    // console.log(\"Points are \", points)\r\n    // const changeColor = (index, color)=>{\r\n    //     console.log(\"Changing color of point \"+index+\" to \",color)\r\n    // }\r\n\r\n    useEffect(() => {\r\n        onRender()\r\n    })\r\n\r\n    var Points = []\r\n    for(let i in points){\r\n        Points.push(<Point \r\n                        points={points}\r\n                        index={i} \r\n                        onChangeColor={onChangeColor}\r\n                        // onClick={onClick}\r\n                    />\r\n                    )\r\n    }\r\n    return Points\r\n    // return (\r\n    //     <>\r\n    //         {points.map((point)=>{\r\n    //             return(\r\n    //                 <>\r\n    //                     <Point \r\n    //                         point={point} \r\n    //                         onChangeColor={ChangeColor()}\r\n    //                         // onClick={onClick}\r\n    //                     />\r\n    //                 </>\r\n    //             )\r\n    //         })}\r\n    //     </>\r\n    // )\r\n}\r\n\r\nexport default Points\r\n","import React, { useState, useRef, useEffect } from 'react'\r\n\r\nconst Canvas = ({id, canvasPoints}) => {\r\n    // console.log(\"titu\",canvasPoints)\r\n    const [points, setPoints]=useState(canvasPoints)\r\n    const [canvas, setCanvas]=useState(useRef(null))\r\n\r\n    const distances=(position, points)=>{\r\n        let dist = new Array(points.length)\r\n        for (let i in points){\r\n            dist[i] =  distance(position, points)\r\n        }\r\n        return dist\r\n    }\r\n\r\n    const distance = (position, point)=>{\r\n        return Math.sqrt(Math.pow(point.x-position.x,2) + Math.pow(point.y-position.y,2))\r\n    }\r\n\r\n    const hsvToRgb=(hsv)=>{\r\n        // console.log(\"converting\", hsv)\r\n        // Using the alternative method provided at https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative\r\n        const f=(n)=>{\r\n            let k = (n + hsv[0]/60) % 6\r\n            let output = hsv[2] - hsv[2]*hsv[1]*Math.max(0, Math.min(k, 4-k, 1))\r\n            return output\r\n        }\r\n        let rgb = [f(5)*255, f(3)*255, f(1)*255, 255]\r\n        // console.log(\"rgb is\",rgb)\r\n        return rgb\r\n    }\r\n\r\n    const getColor=(position)=>{\r\n        // let dist = distances(position, points)\r\n        let invSum = 0\r\n        let hsv = [0,0,0]\r\n        // var t1, t0\r\n        // t0 = Date.now()\r\n        let colour = points[0].colour\r\n        for(let i in points){\r\n            // console.log(\"distance from point \"+i+\" is\"+distance(position, points[i]))\r\n            // t0 = Date.now()\r\n            let d = distance(position, points[i])\r\n            // t1=Date.now()-t0\r\n            // if(t1) console.log(\"distance elapsed=\", t1)\r\n            invSum += 1/d\r\n            // console.log(\"d\", d)\r\n            // console.log(\"invSum\", invSum)\r\n            // t0 = Date.now()\r\n            // hsv.h += 1/d*points[i].colour.h\r\n            // hsv.s += 1/d*points[i].colour.s\r\n            // hsv.v += 1/d*points[i].colour.v      \r\n            \r\n            colour = points[i].colour\r\n            hsv[0] += 1/d*colour.h\r\n            hsv[1] += 1/d*colour.s\r\n            hsv[2] += 1/d*colour.v     \r\n            // t1=Date.now()-t0\r\n            // if(t1) console.log(\"hsv elapsed=\", t1)\r\n            // console.log(\"hsv is \", hsv)\r\n        }\r\n        // t1=Date.now()-t0\r\n        // if(t1) console.log(\"hsv elapsed=\", t1)   \r\n        // console.log(\"hsv is \", hsv)\r\n        hsv[0] /= invSum\r\n        hsv[1] /= invSum\r\n        hsv[2] /= invSum\r\n        return hsvToRgb(hsv)\r\n    }\r\n\r\n    const shootPixel=()=>{\r\n        var ctx = canvas.current.getContext('2d')\r\n        canvas.current.width = canvas.current.offsetWidth\r\n        canvas.current.height = canvas.current.offsetHeight\r\n        // console.log(\"context\", ctx)\r\n        const imageData = ctx.createImageData(canvas.current.width, canvas.current.height)\r\n        // console.log(\"canvasPoints are\", points)\r\n        // console.log(canvas.current.offsetWidth, canvas.current.offsetHeight)\r\n        // console.log(canvas.current.width, canvas.current.height)\r\n        // getColor({x:100,y:100}, points)\r\n        if(points){\r\n            // let rgb = hsvToRgb(getColor({x:100,y:100}, points))\r\n            // console.log(\"hello\", points, points.length)\r\n            // console.log(\"color is\",rgb)\r\n            // console.log(\"Start array computation now\")\r\n            // var t1, t0\r\n            // t0 = Date.now()\r\n            // var hsv = new Array(4*canvas.current.width, canvas.current.height)\r\n            let count=0\r\n            for(let y=0;y<canvas.current.width;y++){\r\n                for(let x=0;x<canvas.current.width;x++){\r\n                    let pixel = getColor({x:x,y:y})\r\n                    // console.log(pixel)\r\n                    imageData.data[count++] = pixel[0]\r\n                    imageData.data[count++] = pixel[1]\r\n                    imageData.data[count++] = pixel[2]\r\n                    imageData.data[count++] = pixel[3]\r\n                    // count++\r\n                }\r\n            }\r\n            // console.log(imageData.data)\r\n            // t1=Date.now()-t0\r\n            // console.log(\"HSV over\")\r\n            // console.log(\"milliseconds elapsed=\", t1)\r\n            \r\n            // for (var i = 0; i < imageData.data.length; i += 4) {\r\n            // // for (var i = 0; i < canvas.current.width*4; i += 4) {\r\n            //     // let x, y\r\n            //     var x = Math.floor(i/4) % canvas.current.width\r\n            //     var y = Math.floor(Math.floor(i/4)/canvas.current.width)\r\n            //     // let rgb = hsvToRgb(getColor({x:x,y:y}, points))\r\n            //     imageData.data[i + 0] = rgb[0];  // R value\r\n            //     imageData.data[i + 1] = rgb[1];    // G value\r\n            //     imageData.data[i + 2] = rgb[2];  // B value\r\n            //     // imageData.data[i + 2] = rgb[2]*x/canvas.current.width;  // B value\r\n            //     imageData.data[i + 3] = 255;\r\n            //     // imageData.data[i + 3] = 255*y/canvas.current.height;  // A value\r\n            //     // imageData.data[i + 3] = 255*x/canvas.current.width;  // A value\r\n            // }\r\n            // const data = imageData.data \r\n            // data = hsv\r\n            ctx.putImageData(imageData, 0, 0);\r\n        }\r\n    }\r\n    useEffect(() => {\r\n        setPoints(canvasPoints)\r\n        shootPixel()\r\n    },)\r\n    return (   \r\n        <canvas id={id} ref={canvas}/>\r\n    )\r\n}\r\n\r\nexport default Canvas\r\n","import {useState, useEffect} from \"react\"\nimport Points from \"./components/Points\"\nimport Canvas from \"./components/Canvas\";\n// import {render} from \"./js/render\"\n\nfunction App() {\n    const [mouseBound, setMouseBound]=useState([\n        {   mouseDown: false,\n            start:{\n                x:0, \n                y:0\n            },\n            end:{\n                x:0, \n                y:0\n            }\n        }\n    ]);\n    var defaultColour = {\n        \"hsl\":{\"h\":53.835616438356155,\"s\":0.8795180722891567,\"l\":0.6745098039215687,\"a\":1},\"hex\":\"#f5e663\",\"rgb\":{\"r\":245,\"g\":230,\"b\":99,\"a\":1},\"hsv\":{\"h\":53.835616438356155,\"s\":0.5959183673469387,\"v\":0.9607843137254902,\"a\":1},\"oldHue\":53.33333333333332,\"source\":\"hex\"\n    }\n    const [dragIs, setDragIs] = useState([\n        {   // While not being dragged, [pointerOffset, currentXY, offset] stores the same value, the X and Y coordinate from the original position (0,0), (used in transform: translate3D(X, Y, 0))\n            // While being dragged, \n            //      pointerOffset[X, Y] stores the pointerOffset X and Y offset of the pointer to the anchor of dragItem\n            //      currentXY[X, Y] stores the total X and Y offsets from the pointerOffset position (0,0).\n            // After a drag event, all [pointerOffset, currentXY, offset] stores the same value, the X and Y coordinate from the original position (0,0); again. \n            ref: null,\n            active: false,\n            colour: defaultColour,\n            showPicker: false,\n            pointerOffset: {x:0, y:0},\n            currentXY: {x:50, y:50},\n            size: false\n        }\n    ])  \n    const getCanvasPoints=(set)=>{\n        let points = new Array(dragIs.length)\n        // console.log(\"setting Canvas points\")\n        for(let i in dragIs){\n            if(dragIs[i].size){\n                // console.log(dragIs[i].currentXY, dragIs[i].size)\n                // console.log(dragIs[i].colour)\n                points[i] = {\n                    x: dragIs[i].currentXY.x+dragIs[i].size[0]/2,\n                    y: dragIs[i].currentXY.y+dragIs[i].size[1]/2,\n                    colour: dragIs[i].colour.hsv\n                }\n            }\n        }\n        // console.log(\"newCanvasPoints are \", points)\n        if (set) setCanvasPoints(points)\n        return points\n    }\n    const [canvasPoints, setCanvasPoints] = useState(false)\n\n    const addDragItem = ()=>{\n        const newDragItem={\n            ref: null,\n            active: false,\n            colour: defaultColour,\n            showPicker: false,\n            pointerOffset: {x:0, y:0},\n            currentXY: {x:50, y:50},\n            size: false\n        }\n        setDragIs([...dragIs, newDragItem])\n    }\n    const removeDragItem = ({index})=>{\n        if (index === -1){\n            index = dragIs.length-1\n        }\n        console.log(\"Removing point with key \"+index)\n        let newDragIs = dragIs\n        newDragIs.splice(index, 1)\n        setDragIs([...newDragIs])\n        console.log(\"New points are \", dragIs)\n    }\n    const dragStart = (e)=>{\n        // mouseDown is to capture off location drags that go over inactive point\n        mouseBound.mouseDown = true;\n        setMouseBound(mouseBound)\n        // capturing target since touch and mouse output different e.target\n        var target = document.elementFromPoint(e.clientX, e.clientY)\n        // if (e.pointerType === \"touch\"){\n        //         target = document.elementFromPoint(e.clientX, e.clientY)\n        // }else{\n        //         target = e.target\n        // }\n        // if(!target.id===\"dragPalette\"){\n        //     console.log(target)\n        // }\n        if(target.classList.contains(\"dragItem\")){\n            // console.log(\"Target is\",target)\n            var index\n            for(let i in dragIs){\n                if(dragIs[i].ref.current === target){\n                    // console.log(\"now \"+ i)\n                    index = i\n                }\n            }\n\n            // console.log(dragIs[index])     \n            console.log(\"dragStart \"+index, dragIs[index])\n            // setting pointerOffset values at the start of a drag \n            let clientXY = {x:0, y:0}\n            if (e.type.substr(0,5) === \"touch\") {\n                clientXY = {x: e.touches[0].clientX, y: e.touches[0].clientY}\n            } else {\n                clientXY = {x: e.clientX, y: e.clientY}\n            }\n            mouseBound.start = clientXY\n            mouseBound.end = clientXY\n            setMouseBound(mouseBound)\n            // console.log(\"Setting mouseBound\", mouseBound)\n            dragIs[index].pointerOffset.x = clientXY.x - dragIs[index].currentXY.x\n            dragIs[index].pointerOffset.y = clientXY.y - dragIs[index].currentXY.y\n            // console.log(\"dragStart \", dragIs[index].object.getBoundingClientRect().left, dragIs[index].object.getBoundingClientRect().top)\n            // console.log(\"dragStart initX, initY = [\" + [dragIs[index].pointerOffset[0], dragIs[index].pointerOffset[1]] + \"]\")\n            dragIs[index].active = true\n            dragIs[index].ref.current.classList.add(\"active\")\n            dragIs[index].ref.current.parentNode.style.zIndex = 1\n            // console.log(\"Now dragIs[index] is\", dragIs[index])\n            setDragIs([...dragIs])\n        }\n    }\n    const drag = (e)=>{\n        if(isAnyAcive()){\n            var index\n            for(let i in dragIs){\n                if(dragIs[i].active){\n                    index = i\n                }\n            }\n            // console.log(\"Pushing...\")\n            e.preventDefault();\n\n            // Calculating current XY \n            let clientXY = {x:0, y:0}\n            if (e.type.substr(0,5) === \"touch\") {\n                clientXY = {x: e.touches[0].clientX, y: e.touches[0].clientY}\n            } else {\n                clientXY = {x: e.clientX, y: e.clientY}\n            }\n            mouseBound.end = clientXY\n            setMouseBound(mouseBound)\n            if(!isClick(mouseBound.start, mouseBound.end)){\n                onPicker(dragIs[index], false)\n                closePickers(index)\n            \n                dragIs[index].currentXY.x = clientXY.x - dragIs[index].pointerOffset.x\n                dragIs[index].currentXY.y = clientXY.y - dragIs[index].pointerOffset.y\n                \n                // let boundXY = [[dragIs[index].ref.current.parentNode.parentNode.getBoundingClientRect().left, \n                //                 dragIs[index].ref.current.parentNode.parentNode.getBoundingClientRect().top\n                //                 ],\n                //                 [0,0]\n                //             ]\n                let boundXY = [[0,0],[0,0]]\n                boundXY[1] = [boundXY[0][0]+dragIs[index].ref.current.parentNode.parentNode.clientWidth-dragIs[index].size[0], \n                                boundXY[0][1]+dragIs[index].ref.current.parentNode.parentNode.clientHeight-dragIs[index].size[1]]\n                // console.log(\"boundXY is\", boundXY);\n                dragIs[index].currentXY.x = Math.max(Math.min(dragIs[index].currentXY.x, boundXY[1][0]), boundXY[0][0])\n                dragIs[index].currentXY.y = Math.max(Math.min(dragIs[index].currentXY.y, boundXY[1][1]), boundXY[0][1])\n                dragIs[index].ref.current.parentNode.style.left = dragIs[index].currentXY.x\n                dragIs[index].ref.current.parentNode.style.top = dragIs[index].currentXY.y\n                // console.log(\"dragIs[index] is\", dragIs[index])\n                \n                setDragIs([...dragIs])\n            }\n\n        }else if(mouseBound.mouseDown){\n            // console.log(\"None active\")\n            // console.log(e)\n            dragStart(e)\n        }\n    }\n    const dragEnd = (e)=>{\n        mouseBound.mouseDown = false;\n        setMouseBound(mouseBound)\n        var index\n        for(let i in dragIs) \n            if(dragIs[i].active)\n                index = i\n        if(index){\n            dragIs[index].pointerOffset.x = dragIs[index].currentXY.x;\n            dragIs[index].pointerOffset.y = dragIs[index].currentXY.y;\n            dragIs[index].ref.current.classList.remove(\"active\")\n            dragIs[index].active = false;\n            \n            // console.log(\"mouseStart\", mouseBound.start)\n            // console.log(\"mouseEnd\", mouseBound.end)\n            // console.log(e, dragIs[index].showPicker)\n            if(isClick(mouseBound.start, mouseBound.end) && !dragIs[index].showPicker){\n                closePickers(index)\n                dragIs[index].ref.current.classList.add(\"active\")\n                dragIs[index].ref.current.parentNode.style.zIndex = 2;\n                onPicker(dragIs[index], true)\n            }\n            else{\n                onPicker(dragIs[index], false)\n                dragIs[index].ref.current.parentNode.style.zIndex = 1;\n            }\n\n            console.log(\"dragEnd \"+index, dragIs[index])\n            setDragIs([...dragIs])\n        }\n    }\n    const closePickers=(index)=>{\n        for(let i in dragIs){\n            dragIs[i].showPicker=false\n            dragIs[i].ref.current.classList.remove(\"active\")\n            dragIs[i].ref.current.parentNode.style.zIndex = 1;\n        }\n        dragIs[index].ref.current.classList.add(\"active\")\n        dragIs[index].ref.current.parentNode.style.zIndex = 2;\n        setDragIs(dragIs)\n    }\n    const isAnyAcive=()=>{\n        let active = false;\n        for (let i in dragIs){\n            active = active || dragIs[i].active; \n        }\n        return active;\n    }\n    const isPickerActive=()=>{\n        let showPicker = false;\n        for (let i in dragIs){\n            showPicker = showPicker || dragIs[i].showPicker; \n        }\n        return showPicker;\n    }\n    const onPicker=(point, state)=>{\n        // if(state)\n        //     point.showPicker = !point.showPicker\n        // else\n            point.showPicker = state\n    }\n    const isClick=(startXY, endXY)=>{\n        let tol=5\n        let value = Math.sqrt(Math.pow(endXY.x-startXY.x,2) + Math.pow(endXY.y-startXY.y,2))\n        return (value<=tol)\n    }\n    const initSizes=()=>{\n        let update = false\n        for (let i in dragIs){\n            // console.log(!dragIs[i].size)\n            if(!dragIs[i].size){\n                // console.log(\"setting size for \"+i )\n                update = true\n                dragIs[i].size = [dragIs[i].ref.current.offsetWidth, dragIs[i].ref.current.offsetHeight]\n            }\n        } \n        if(update) setDragIs(dragIs)\n    } \n    const onChangeColor=(index, color)=>{\n        // console.log(\"changing color of \"+ index, color)\n        let newDragIs = [...dragIs]\n        newDragIs[index].colour = color\n        setDragIs([...newDragIs])\n    }\n    useEffect(() => {\n        // console.log(\"dragIs were updated, updating points\")\n        getCanvasPoints(true)\n    }, [dragIs])\n\n\n    return (\n        <div className=\"App\" \n            // onTouchStart={(e)=>dragStart(e)} \n            // onMouseDown={(e)=>dragStart(e)}\n            // onTouchMove={(e)=>drag(e)} \n            // onMouseMove={(e)=>drag(e)}\n            // onTouchEnd={(e)=>dragEnd(e)} \n            // onMouseUp={(e)=>dragEnd(e)}\n\n            onPointerDown={(e)=>dragStart(e)} \n            onPointerMove={(e)=>drag(e)} \n            onPointerUp={(e)=>dragEnd(e)} \n        >\n            <div id=\"outerContainer\">\n                <div id=\"dragPalette\">\n                    <Canvas id={\"gradientPalette\"} canvasPoints={canvasPoints}/>\n                    <Points points={dragIs} onRender={initSizes} onChangeColor={onChangeColor}/>\n                </div>\n                <div id=\"point-manager\">\n                        <button className=\"button plus\" onClick={addDragItem}></button>\n                        <button className=\"button minus\" onClick={()=> removeDragItem({index: -1})}></button>\n                </div>\n                </div>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport './css/style.css';\nimport './css/dragPalette.css';\nimport './css/pointManager.css';\nimport App from './App';\n// import dragHandle from './js/dragHandler';\nimport reportWebVitals from './reportWebVitals';\n\n// var dragIs;\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n// dragIs = dragHandle();"],"sourceRoot":""}