{"version":3,"sources":["reportWebVitals.js","index.js","App.js","js/webglUtils.js","js/gradientRenderer.js","components/Canvas.js","components/Point.js","components/Points.js"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","App","document","getElementById","initDragIs","useState","potChange","setPotChange","renderPage","setRenderPage","window","location","origin","setUrl","useLocation","down","stateSaved","clicked","status","index","undefined","obj","showRadius","active","resizing","mode","start","target","initialPosition","x","y","initialRadius","pos","middle","end","getXY","from","this","mouse","setMouse","view","setView","undo","setUndo","redo","setRedo","undoRedo","setUndoRedo","rgbToHslHsvHex","rgb","M","m","C","hue","V","L","rgbArr","r","g","b","Math","max","min","hsv","h","s","v","a","hsl","abs","l","hex","i","colorcode","floor","toString","repeat","length","defaultColour","random","paramsHash","URLSearchParams","search","params","entries","pair","JSON","parse","Buffer","Error","pointRef","containerRef","radius","colour","showPicker","currentXY","size","containerSize","dragIs","setDragIs","hsvRgbObjToArr","arr","getCanvasPoints","set","points","Array","centre","pointCentre","colourArr","setCanvasPoints","canvasPoints","dragStart","e","getPointerLocation","elementFromPoint","getIndex","classList","contains","hideButton","init","tags","current","style","zIndex","type","substr","touches","clientX","clientY","state","timeout","animTime","setTimeout","undoButton","getElementsByClassName","k","add","transition","remove","getBounds","boundXY","parentNode","clientWidth","clientHeight","closePoint","pushNewURL","push","url_query","stringify","removeDOMItems","href","history","pushState","replaceState","dist","p1","p2","sqrt","pow","isClick","startXY","endXY","pushToView","dontCopyToRedo","newView","copyDragIs","differentState","newState","oldState","minimalState","item","error","console","undoRedoClicked","action","slice","useEffect","err","reset","log","className","onPointerDown","onPointerMove","preventDefault","drag","onPointerUp","dragEnd","id","onRender","update","offsetWidth","offsetHeight","onChangeColor","color","finish","newDragIs","onPickerButton","onClick","newDragItem","ref","pointerOffset","splice","removeDragItem","WebGLDebugUtil","require","msg","errorRE","addLineNumbersWithError","src","matches","matchAll","lineNoToErrorMap","Map","map","ndx","lineNo","parseInt","next","substring","split","line","get","join","loadShader","gl","shaderSource","shaderType","opt_errorCallback","errFn","shader","createShader","compileShader","getShaderParameter","COMPILE_STATUS","lastError","getShaderInfoLog","deleteShader","createProgram","shaders","opt_attribs","opt_locations","program","forEach","attachShader","attrib","bindAttribLocation","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","getShaderSource","SHADER_TYPE","glEnumToString","deleteProgram","defaultShaderType","createProgramFromSources","shaderSources","ii","renderGradient","canvas","getContext","width","height","locations","position","getAttribLocation","resolution","getUniformLocation","pointsRadius","pointsXY","pointsRGB","pointsHSV","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","positions","bufferData","Float32Array","STATIC_DRAW","vao","createVertexArray","bindVertexArray","enableVertexAttribArray","FLOAT","offset","vertexAttribPointer","multiplier","resizeCanvasToDisplaySize","viewport","useProgram","uniform1fv","flat","uniform2iv","uniform3fv","uniform2f","primType","TRIANGLES","count","drawArrays","worker","Worker","Canvas","setPoints","useRef","draw","imageData","putImageData","requestAnimationFrame","shootPixel","createImageData","imDataLength","data","terminate","postMessage","onerror","onmessage","alert","Point","styles","reactCSS","default","container","left","top","pointContainer","display","justifyContent","alignItems","flexWrap","point_unclicked","backgroundColor","point_clicked","pickerButton","fontSize","transform","pickerBar","tabIndex","onChange","onChangeComplete","disableAlpha","presetColors","defaultProps","Points"],"mappings":"0LAYeA,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,O,eCGdQ,IAASC,OACL,cAAC,IAAMC,WAAP,UACI,cAAC,IAAD,UACI,cAACC,EAAA,EAAD,QAGRC,SAASC,eAAe,SAM5Bd,K,qJC4yBeY,IA5zBf,WAKI,IAmIIG,EAnIJ,EAAkCC,oBAAS,GAA3C,mBAAOC,EAAP,KAAkBC,EAAlB,KACA,EAAoCF,oBAAS,GAA7C,mBAAOG,EAAP,KAAmBC,EAAnB,KAKA,EAAsBJ,mBAASK,OAAOC,SAASC,QAA/C,mBAAYC,GAAZ,WACMF,EAAWG,cAEjB,EAA0BT,mBAAS,CAE/BU,MAAM,EAENC,YAAY,EAEZC,QAAS,CAELC,QAAQ,EAERC,WAAOC,EAEPC,SAAKD,GAGTE,YAAY,EACZC,QAAQ,EAERC,SAAU,CAENC,MAAM,EAENC,OAAO,GAGXC,OAAQ,CAEJN,SAAKD,EAELD,WAAOC,EAEPQ,gBAAiB,CACbC,EAAG,EACHC,EAAG,GAGPC,mBAAeX,GAGnBY,IAAK,CAEDN,MAAO,CACHG,EAAG,EACHC,EAAG,GAGPG,OAAQ,CACJJ,EAAG,EACHC,EAAG,GAGPI,IAAK,CACDL,EAAG,EACHC,EAAG,GAGPK,MAAO,SAAUC,GACb,MAAa,UAATA,EAAyB,CAACC,KAAKX,MAAMG,EAAGQ,KAAKX,MAAMI,GACrC,WAATM,EACE,CAACC,KAAKJ,OAAOJ,EAAGQ,KAAKJ,OAAOH,GACrB,QAATM,EAAuB,CAACC,KAAKH,IAAIL,EAAGQ,KAAKH,IAAIJ,QAAjD,MA5DjB,mBAAOQ,EAAP,KAAcC,EAAd,KAoEA,EAAwBlC,mBAAS,IAAjC,mBAAOmC,EAAP,KAAaC,EAAb,KACA,EAAwBpC,mBAAS,IAAjC,mBAAOqC,EAAP,KAAaC,EAAb,KACA,EAAwBtC,mBAAS,IAAjC,mBAAOuC,EAAP,KAAaC,EAAb,KAIA,EAAgCxC,oBAAS,GAAzC,mBAAOyC,EAAP,KAAiBC,EAAjB,KAOMC,EAAiB,SAACC,GACpB,IACIC,EAAGC,EAAGC,EAAGC,EAAKC,EAAGC,EADjBC,EAAS,CAACP,EAAIQ,EAAGR,EAAIS,EAAGT,EAAIU,GAOtB,KAHVP,GAFAF,EAAIU,KAAKC,IAAL,MAAAD,KAAYJ,KAChBL,EAAIS,KAAKE,IAAL,MAAAF,KAAYJ,KAIHH,EAAM,EACVH,IAAMM,EAAO,GAAIH,GAAQG,EAAO,GAAKA,EAAO,IAAMJ,EAAK,EACvDF,IAAMM,EAAO,GAAIH,GAAOG,EAAO,GAAKA,EAAO,IAAMJ,EAAI,EACrDF,IAAMM,EAAO,KAAIH,GAAOG,EAAO,GAAKA,EAAO,IAAMJ,EAAI,GAY9D,IAAIW,EAAM,CAAEC,EADZX,IAVAA,GAAO,IAUO,IAAO,KAAO,IACRY,EANV,KAHVX,EAAIJ,EAAI,KAGU,EACRE,GAAS,IAAJE,GAKYY,EAAGZ,EAAGa,EAAG,GAChCC,EAAM,CAAEJ,EAAGX,EAAKY,EALV,KAJVV,GAAKL,EAAIC,GAAL,MAIiB,IAANI,EAAc,EACnBH,GAAK,KAAO,EAAIQ,KAAKS,IAAI,EAAId,EAAI,KAIhBe,EAAGf,EAAGY,EAAG,GACpClB,EAAIkB,EAAI,EACR,IAAII,EAAM,IACV,IAAK,IAAIC,KAAKhB,EAAQ,CAClB,IAAIiB,EAAYb,KAAKc,MAAMlB,EAAOgB,IAAIG,SAAS,IAC/CJ,GAAO,IAAIK,OAAO,EAAIH,EAAUI,QAAUJ,EAE9C,MAAO,CAAExB,IAAKA,EAAKc,IAAKA,EAAKK,IAAKA,EAAKG,IAAKA,IAG5CO,EAAgB9B,EAAe,CAC/BS,EAAmB,IAAhBG,KAAKmB,SACRrB,EAAmB,IAAhBE,KAAKmB,SACRpB,EAAmB,IAAhBC,KAAKmB,WAERC,EAAa,IAAIC,gBAAgBvE,OAAOC,SAASuE,QACjDC,EAAS,GAEb,IAAK,IAAD,gBACiBH,EAAWI,WAD5B,IACA,2BAAuC,CAAC,IAA/BC,EAA8B,QACnCF,EAAOE,EAAK,IAAMC,KAAKC,MACnBC,EAAOpD,KAAKiD,EAAK,GAAI,UAAUV,aAHvC,gCAWA,KAAI,WAAYQ,GACX,MAAM,IAAIM,MAAM,cADGrF,EAAa+E,EAAM,OAE7C,UACE/E,EAAa,CACT,CAEIsF,SAAU,KAEVC,aAAc,KAEdC,OAAQ,EAERC,OAAQf,EAERgB,YAAY,EAEZC,UAAW,CAAElE,EAAG,GAAIC,EAAG,IAEvBkE,UAAM5E,EAEN6E,mBAAe7E,IAO3B,MAA4Bf,mBAASD,GAArC,oBAAO8F,GAAP,MAAeC,GAAf,MAOMC,GAAiB,SAAC/E,GACpB,IAAIgF,EAAM,CACN,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAIX,OAFAA,EAAI,GAAK,CAAChF,EAAI0C,IAAIC,EAAG3C,EAAI0C,IAAIE,EAAG5C,EAAI0C,IAAIG,GACxCmC,EAAI,GAAK,CAAChF,EAAI4B,IAAIQ,EAAGpC,EAAI4B,IAAIS,EAAGrC,EAAI4B,IAAIU,GACjC0C,GAQLC,GAAkB,SAACC,GACrB,IAAIC,EAAS,IAAIC,MAAMP,GAAOrB,QAC9B,IAAK,IAAIL,KAAK0B,GACV,GAAIA,GAAO1B,GAAGwB,KAAM,CAChB,IAAIU,EAASC,GAAYnC,GACzBgC,EAAOhC,GAAK,CACR3C,EAAG6E,EAAO7E,EACVC,EAAG4E,EAAO5E,EACV+D,OAAQK,GAAO1B,GAAGqB,OAClBe,UAAWR,GAAeF,GAAO1B,GAAGqB,QACpCD,OAAQM,GAAO1B,GAAGoB,QAI9B,IAAIW,EACC,OAAOC,EADHK,GAAgBL,IAG7B,GAAwCnG,oBAAS,GAAjD,qBAAOyG,GAAP,MAAqBD,GAArB,MAoEME,GAAY,SAACC,GAAO,IAAD,MACrB1E,EAAMvB,MAAO,EACbuB,EAAMN,IAAIN,MAAQuF,GAAmBD,GAGrC1E,EAAMX,OAAON,KAAM,EAAAnB,UAASgH,iBAAT,oBACZ5E,EAAMN,IAAIG,MAAM,WAGvB,IAAIhB,EAAQgG,GAAS7E,EAAMX,OAAON,KAEvBiB,EAAMX,OAAOR,MAApBA,QACsBC,EAGrBkB,EAAMX,OAAON,IAAI+F,UAAUC,SAAS,aACrCC,IAAW,EAAO,EAAG,QAMrBhF,EAAMX,OAAON,IAAI+F,UAAUC,SAAS,eAClC/E,EAAMrB,QAAQC,QACfoB,EAAMrB,QAAQC,QACXoB,EAAMrB,QAAQE,QAAUmB,EAAMX,OAAOR,QACpCmB,EAAMhB,YAEPH,IAIAmB,EAAMX,OAAO4F,KAAO,CAChB1F,EACIqE,GAAO5D,EAAMX,OAAOR,OAAO4E,UAAUlE,EACrCS,EAAMN,IAAIN,MAAMG,EACpBC,EACIoE,GAAO5D,EAAMX,OAAOR,OAAO4E,UAAUjE,EACrCQ,EAAMN,IAAIN,MAAMI,GAExBQ,EAAMf,QAAS,EAEf2E,GAAO5D,EAAMX,OAAOR,OAAOqG,KAAO,CAAEjG,QAAQ,GAC5C2E,GACI5D,EAAMX,OAAOR,OACfwE,aAAa8B,QAAQC,MAAMC,OAAS,GAK1CrF,EAAMrB,QAAQC,QACdoB,EAAMrB,QAAQE,QAAUmB,EAAMX,OAAOR,QADrC,UAEA+E,GAAO5D,EAAMrB,QAAQE,cAFrB,iBAEA,EAA6BqG,YAF7B,aAEA,EAAmClG,cAKnCgB,EAAMd,SAASC,MAAO,EACtBa,EAAMhB,YAAa,EACnBgB,EAAMX,OAAOI,cAAgBmE,GAAO5D,EAAMrB,QAAQE,OAAOyE,QAE7DO,GAAU,YAAID,KACdzF,GAAc,GACd8B,EAASD,IAqIP6E,GAAW,SAAC9F,GACd,IAAK,IAAImD,KAAK0B,GACV,GAAIA,GAAO1B,GAAGkB,SAAS+B,UAAYpG,EAC/B,OAAOmD,GAKbyC,GAAqB,SAACD,GAUxB,MAR4B,UAAxBA,EAAEY,KAAKC,OAAO,EAAG,GACN,CACPhG,EAAGmF,EAAEc,QAAQ,GAAGC,QAChBjG,EAAGkF,EAAEc,QAAQ,GAAGE,SAGT,CAAEnG,EAAGmF,EAAEe,QAASjG,EAAGkF,EAAEgB,UA9e7B,SAkfIV,GAlfJ,qFAkfX,WAA0BW,EAAOC,EAASC,GAA1C,SAAAhE,EAAA,sDACS8D,QAAqB7G,IAAZ8G,IAAuBA,EAAU,UAC9B9G,IAAb+G,IACWA,EAAPF,EAAkB,QACN,MAEpBG,YAAW,WACP,IAAIC,EAAanI,SAASoI,uBAAuB,cACjD,IAAK,IAAIC,KAAKF,EACNA,EAAWE,GAAGnB,YACVa,GACAI,EAAWE,GAAGnB,UAAUoB,IAAI,UAC5BH,EACIE,GACFb,MAAMe,WAFR,8DAE4EN,EAF5E,kBAIAE,EAAWE,GAAGnB,UAAUsB,OAAO,UAC/BL,EACIE,GACFb,MAAMe,WAFR,8DAE4EN,EAF5E,oBAKbD,GAtBP,4CAlfW,sBA0gBX,IAAMvB,GAAc,SAACxF,GAKjB,MAJa,CACTU,EAAGqE,GAAO/E,GAAO4E,UAAUlE,EAAIqE,GAAO/E,GAAO8E,cAAc,GAAK,EAChEnE,EAAGoE,GAAO/E,GAAO4E,UAAUjE,EAAIoE,GAAO/E,GAAO8E,cAAc,GAAK,IAIlE0C,GAAY,SAACxH,GACf,IAAIyH,EAAU,CACV,GACM1C,GAAO/E,GAAO8E,cAAc,GAAKC,GAAO/E,GAAO6E,KAAK,IAAM,IAC1DE,GAAO/E,GAAO8E,cAAc,GAAKC,GAAO/E,GAAO6E,KAAK,IAAM,GAEhE,CAAC,EAAG,IAUR,OARA4C,EAAQ,GAAK,CACTA,EAAQ,GAAG,GACP1C,GAAO/E,GAAOwE,aAAa8B,QAAQoB,WAAWC,YAC9C5C,GAAO/E,GAAO6E,KAAK,GACvB4C,EAAQ,GAAG,GACP1C,GAAO/E,GAAOwE,aAAa8B,QAAQoB,WAAWE,aAC9C7C,GAAO/E,GAAO6E,KAAK,IAEpB4C,GAELI,GAAa,WAAwB,IAAvB7H,EAAsB,4DAAdC,EAExB,IAAK,IAAIoD,KADRrD,IAAUmB,EAAMrB,QAAQC,QAAS,GACpBgF,GACN/E,IAAUqD,IAGV0B,GAAO1B,GAAGgD,aAAatB,GAAO1B,GAAGgD,KACrCtB,GAAO1B,GAAGmB,aAAa8B,QAAQC,MAAMC,OAAS,GAElDxB,GAAUD,KAER+C,GAAa,WAA2C,IAAD,yDAAP,GAAO,IAAvChB,aAAuC,MAA/B/B,GAA+B,MAAvBgD,YAAuB,SACrDC,EACAzI,OAAOC,SAASC,OAChB,YACA4E,EAAOpD,KAAKkD,KAAK8D,UAAUC,GAAepB,KAAStD,SAC/C,UAYJjE,OAAOC,SAAS2I,OAASH,IACrBD,EAAMxI,OAAO6I,QAAQC,UAAU,KAAM,KAAML,GAC1CzI,OAAO6I,QAAQE,aAAa,KAAM,KAAMN,IAIjDtI,EAAOsI,IAYLO,GAAO,SAACC,EAAIC,GACd,OAAOhG,KAAKiG,KAAKjG,KAAKkG,IAAIH,EAAG9H,EAAI+H,EAAG/H,EAAG,GAAK+B,KAAKkG,IAAIH,EAAG7H,EAAI8H,EAAG9H,EAAG,KAEhEiI,GAAU,SAACC,EAASC,GAGtB,OADYP,GAAKO,EAAOD,IADd,GA8BRE,GAAa,SAACjC,GAAmC,IAA5BkC,EAA2B,wDAClD,GAAIA,EAAgB,CAChB,IAAIC,EAAUC,GAAWpC,GACzBxF,EAAQ2H,QACL,GAAIE,GAAerC,EAAOzF,GAAO,CACpCG,EAAQ,GAAD,mBAAKD,GAAL,CAAWF,KAClBK,EAAQ,IACR,IAAIuH,EAAUC,GAAWpC,GACzBxF,EAAQ2H,GACRnB,GAAWhB,KAGbqC,GAAiB,SAACC,EAAUC,GAE1BlF,KAAK8D,UAAUC,GAAekB,IAC9BjF,KAAK8D,UAAUC,GAAemB,IAClC,OACIlF,KAAK8D,UAAUC,GAAekB,KAC9BjF,KAAK8D,UAAUC,GAAemB,KAGhCH,GAAa,SAACpC,GAEhB,OADgB3C,KAAKC,MAAMD,KAAK8D,UAAUC,GAAepB,MAGvDoB,GAAiB,SAACpB,GACpB,IAAIwC,EAAe,GACnB,IAAK,IAAIjG,KAAKyD,EAAO,CACjB,IAAIyC,EAAI,eAAQzC,EAAMzD,IACtB,IACIkG,EAAKhF,cAAWtE,EAChBsJ,EAAK/E,kBAAevE,SACbsJ,EAAKlD,KACd,MAAOmD,GACLC,QAAQD,MAAM,kCAAmCA,GAErDF,EAAavB,KAAKwB,GAEtB,OAAOD,GAgBLI,GAAkB,SAACC,GACN,SAAXA,GAAqBpI,EAAKmC,QAC1BhC,EAAQ,GAAD,mBAAKD,GAAL,CAAWJ,KAClB2D,GAAUzD,EAAKA,EAAKmC,OAAS,IAC7BlC,EAAQD,EAAKqI,MAAM,EAAGrI,EAAKmC,OAAS,IACpC9B,GAAY,GACZxC,GAAa,GACbE,GAAc,IACI,SAAXqK,GAAqBlI,EAAKiC,SACjClC,EAAQ,GAAD,mBAAKD,GAAL,CAAWF,KAClB2D,GAAUvD,EAAKA,EAAKiC,OAAS,IAC7BhC,EAAQD,EAAKmI,MAAM,EAAGnI,EAAKiC,OAAS,IACpC9B,GAAY,GACZxC,GAAa,GACbE,GAAc,IAElB6B,EAAMvB,MAAO,EACbkI,MAuEJ,OArEA+B,qBAAU,WACN,GAAIxK,EACA,IACI8F,IAAgB,GAChB7F,GAAc,GAChB,MAAOwK,IACLL,QAAQD,MAAM,2BAA4BM,IAG9C3K,IACA4J,GAAWhE,GAAQpD,GACfA,GAAUC,GAAY,GAC1BxC,GAAa,MAElB,CAACC,IACJwK,qBAAU,WACN,IAAIhG,EAAa,IAAIC,gBAAgBvE,OAAOC,SAASuE,QACjDC,EAAS,GACT+F,GAAQ,EACZ,IAAK,IAAD,gBACiBlG,EAAWI,WAD5B,IACA,2BAAuC,CAAC,IAA/BC,EAA8B,QACnCF,EAAOE,EAAK,IAAMC,KAAKC,MACnBC,EAAOpD,KAAKiD,EAAK,GAAI,UAAUV,aAHvC,gCASA,KAAM,WAAYQ,GAAS,CACvB+F,GAAQ,EACR,IAAIpG,EAAgB9B,EAAe,CAC/BS,EAAmB,IAAhBG,KAAKmB,SACRrB,EAAmB,IAAhBE,KAAKmB,SACRpB,EAAmB,IAAhBC,KAAKmB,WAEZI,EAAM,OAAa,CACf,CACIO,SAAU,KACVC,aAAc,KACdC,OAAQ,EACRC,OAAQf,EACRgB,YAAY,EACZC,UAAW,CAAElE,EAAG,GAAIC,EAAG,IACvBkE,UAAM5E,EACN6E,mBAAe7E,IAI3B+E,GAAU,YAAIhB,EAAM,SACpBxC,EAAQ,GAAD,mBAAKD,GAAL,CAAWF,KAClBK,EAAQ,IACR,IAAIuH,EAAUC,GAAWlF,EAAM,QAC/B1C,EAAQ2H,GACRrH,GAAY,GACZxC,GAAa,GACbE,GAAc,GACdwI,GAAW,CAAEC,KAAMgC,IACrB,MAAOP,GACLC,QAAQO,IAAI,8CAA+CR,MAEhE,CAAChK,IACJqK,qBAAU,WACN1E,IAAgB,GAChB7F,GAAc,GACdyJ,GAAWhE,IAAQ,GACnB3F,GAAa,GACb+G,IAAW,EAAO,KACZ,WAAYnC,GAAS8D,GAAW,CAAEC,MAAM,MAC/C,IAEC,qBACIkC,UAAU,MACVC,cAAe,SAACrE,GAAD,OAAOD,GAAUC,IAChCsE,cAAe,SAACtE,GAAD,OA1aV,SAACA,GAGV,GAFA1E,EAAMN,IAAIC,OAASgF,GAAmBD,GAElC1E,EAAMf,SAAWwI,GAAQzH,EAAMN,IAAIN,MAAOY,EAAMN,IAAIC,QAAS,CAC7D+G,KACA,IAAI7H,EAAQmB,EAAMX,OAAOR,MACzB,GAAIA,EAAO,CACP6F,EAAEuE,iBACFjE,IAAW,EAAM,GACjB,IACIpB,GAAO/E,GAAOwE,aAAa8B,QAAQC,MAAMC,OAAS,EACpD,UACF,IAAI5B,EAAY,CAAElE,EAAG,EAAGC,EAAG,GAC3BiE,EAAUlE,EAAIS,EAAMN,IAAIC,OAAOJ,EAAIS,EAAMX,OAAO4F,KAAK1F,EACrDkE,EAAUjE,EAAIQ,EAAMN,IAAIC,OAAOH,EAAIQ,EAAMX,OAAO4F,KAAKzF,EAIrD,IAAI8G,EAAUD,GAAUxH,GACxB+E,GAAO/E,GAAO4E,UAAUlE,EAAI+B,KAAKC,IAC7BD,KAAKE,IAAIiC,EAAUlE,EAAG+G,EAAQ,GAAG,IACjCA,EAAQ,GAAG,IAEf1C,GAAO/E,GAAO4E,UAAUjE,EAAI8B,KAAKC,IAC7BD,KAAKE,IAAIiC,EAAUjE,EAAG8G,EAAQ,GAAG,IACjCA,EAAQ,GAAG,UAKlB,GAAItG,EAAMd,SAASC,MACpB,GAAIa,EAAMrB,QAAQE,MAAO,CACrB,IAAIsC,EAAIiG,GAAK/C,GAAYrE,EAAMrB,QAAQE,OAAQ,CAC3CU,EAAGS,EAAMN,IAAIC,OAAOJ,EAAI,GACxBC,EAAGQ,EAAMN,IAAIC,OAAOH,EAAI,KAExBQ,EAAMd,SAASE,MACfwE,GAAO5D,EAAMrB,QAAQE,OAAOyE,OAAShC,KAAKC,IACtCD,KAAKS,IAAIZ,GAAK,GACd,GAEGA,EAAI,IAAMnB,EAAMX,OAAOI,gBAC9BmE,GAAO5D,EAAMrB,QAAQE,OAAOqG,KACrBtB,GAAO5D,EAAMrB,QAAQE,OAAOqG,KAAKhG,UAAW,EAC5C0E,GAAO5D,EAAMrB,QAAQE,OAAOqG,KAAO,CAChChG,UAAU,GAEpBc,EAAMd,SAASE,OAAQ,SAGxBY,EAAMvB,MACbgG,GAAUC,GAEdb,GAAU,YAAID,KACV5D,EAAMvB,MAENN,GAAc,GAElB8B,EAASD,GAgXiBkJ,CAAKxE,IAC3ByE,YAAa,SAACzE,GAAD,OA/WL,SAACA,GAEe,UAAxBA,EAAEY,KAAKC,OAAO,EAAG,GACjBvF,EAAMN,IAAIE,IAAM,CACZL,EAAGmF,EAAEc,QAAQ,GAAGC,QAChBjG,EAAGkF,EAAEc,QAAQ,GAAGE,SAGpB1F,EAAMN,IAAIE,IAAM,CAAEL,EAAGmF,EAAEe,QAASjG,EAAGkF,EAAEgB,SAEzC,IAAI7G,EAAQmB,EAAMX,OAAOR,MACzB,GAAIA,EAAO,CACP,IAAIQ,EAASzB,SAASgH,iBAAiBF,EAAEe,QAASf,EAAEgB,SAEpD,GACI+B,GAAQzH,EAAMN,IAAIN,MAAOY,EAAMN,IAAIE,OAClCP,EAAOyF,UAAUC,SAAS,aACvB1F,EAAOyF,UAAUC,SAAS,gBAChC,CACE,IACInB,GAAO/E,GAAOwE,aAAa8B,QAAQC,MAAMC,OAASzB,GAC9C/E,GACFF,QACI,EACA,EACR,UACF,IAEKqB,EAAMrB,QAAQC,QACdoB,EAAMrB,QAAQI,KAAOiB,EAAMrB,QAAQI,MAAQM,EAC9C,CACEW,EAAMrB,QAAQC,QAAS,EACvBoB,EAAMrB,QAAQI,IAAMM,EACpBW,EAAMrB,QAAQE,MAAQgG,GAASxF,GAC/BqH,GAAW1G,EAAMrB,QAAQE,OACzBmB,EAAMhB,YAAa,EACnB,IACI4E,GAAO5D,EAAMrB,QAAQE,OAAOqG,KAAO,CAC/BvG,SAAS,EACTK,YAAY,GAElB,gBACKgB,EAAMrB,QAAQI,KAAOiB,EAAMrB,QAAQI,MAAQM,IAClDW,EAAMrB,QAAQC,QAAS,EACvB8H,KACA1G,EAAMrB,QAAQI,SAAMD,EACpBkB,EAAMrB,QAAQE,WAAQC,QAEvB,GAAIkB,EAAMd,SAASE,aACfwE,GAAO/E,GAAOqG,KAAKhG,cACvB,GAAIc,EAAMf,OAAQ,CACrB+F,IAAW,GACX0B,KACA1G,EAAMf,QAAS,EACf,IACI2E,GAAO/E,GAAOwE,aAAa8B,QAAQC,MAAMC,OAAS,EACpD,WAENrF,EAAMvB,MAAO,EACbuB,EAAMf,QAAS,EACfe,EAAMd,SAASC,MAAO,EACtBa,EAAMd,SAASE,OAAQ,EACvByE,GAAU,YAAID,KACd3D,EAASD,QAETA,EAAMvB,MAAO,EACboF,GAAU,YAAID,KAElB3F,GAAa,GACbE,GAAc,GA0SUiL,CAAQ1E,IAJhC,SAMI,sBAAK2E,GAAG,iBAAR,UACI,qBAAKA,GAAG,cAAR,SACI,cAAC,IAAD,CACIA,GAAI,kBACJ7E,aAAcA,OAGtB,cAAC,IAAD,CACIN,OAAQN,GACR0F,SAxLI,WAChB,IAAIC,GAAS,EACb,IAAK,IAAIrH,KAAK0B,GACLA,GAAO1B,GAAGwB,OACX6F,GAAS,EACT3F,GAAO1B,GAAGwB,KAAO,CACbE,GAAO1B,GAAGkB,SAAS+B,QAAQqE,YAC3B5F,GAAO1B,GAAGkB,SAAS+B,QAAQsE,cAE/B7F,GAAO1B,GAAGyB,cAAgB,CACtBC,GAAO1B,GAAGkB,SAAS+B,QAAQoB,WAAWA,WACjCiD,YACL5F,GAAO1B,GAAGkB,SAAS+B,QAAQoB,WAAWA,WACjCkD,eAIbF,GAAQ1F,GAAUD,KAwKV8F,cAtKM,SAAC7K,EAAO8K,GAA2B,IAApBC,EAAmB,wDAChDC,EAAS,YAAOjG,IACpBiG,EAAUhL,GAAO0E,OAASoG,EAC1B9F,GAAU,YAAIgG,IACd1L,GAAc,GACVyL,GAAQ3L,GAAa,IAkKb6L,eAxHO,SAACjL,GAChB+E,GAAO/E,GAAOqG,KACVtB,GAAO/E,GAAOqG,KAAK1B,mBACZI,GAAO/E,GAAOqG,KAAK1B,WAC1BI,GAAO/E,GAAOqG,KAAKlG,YAAa,EAChCgB,EAAMhB,YAAa,IAEnB4E,GAAO/E,GAAOqG,KAAK1B,YAAa,SACzBI,GAAO/E,GAAOqG,KAAKlG,WAC1BgB,EAAMhB,YAAa,GAEpB4E,GAAO/E,GAAOqG,KAAO,CAAE1B,YAAY,GAC1CK,GAAU,YAAID,QA8GN,sBAAKyF,GAAG,gBAAR,UACI,wBACIP,UAAU,gCACViB,QA9jBA,WAChB,IACIxG,EADAE,EAAY,CAAElE,EAAG,GAAIC,EAAG,IAE5B,GAAIoE,GAAOrB,OAAS,EAAG,CACnB,IAAI+D,EAAU,CACV,CAAC,EAAG,GACJ,CAAC,EAAG,IAERA,EAAQ,GAAK,CACTA,EAAQ,GAAG,GACP1C,GAAO,GAAGP,aAAa8B,QAAQoB,WAAWC,YAC1C5C,GAAO,GAAGF,KAAK,GACnB4C,EAAQ,GAAG,GACP1C,GAAO,GAAGP,aAAa8B,QAAQoB,WAAWE,aAC1C7C,GAAO,GAAGF,KAAK,IAKvBD,EAAY,CAAElE,EAFV+B,KAAKc,MAAMd,KAAKmB,SAAW6D,EAAQ,GAAG,GAAKA,EAAQ,GAAG,IAEtC9G,EADhB8B,KAAKc,MAAMd,KAAKmB,SAAW6D,EAAQ,GAAG,GAAKA,EAAQ,GAAG,KAG9D/C,EAAS,CACLpC,EAAmB,IAAhBG,KAAKmB,SACRrB,EAAmB,IAAhBE,KAAKmB,SACRpB,EAAmB,IAAhBC,KAAKmB,UAGZ,IAAMuH,EAAc,CAChBC,IAAK,KACL5G,aAAc,KACdC,OAAQ,EACRC,OALJA,EAAS7C,EAAe6C,GAMpBC,YAAY,EACZ0G,cAAe,CAAE3K,EAAG,EAAGC,EAAG,GAC1BiE,UAAWA,EACXC,UAAM5E,EACN6E,mBAAe7E,GAEnB+E,GAAU,GAAD,mBAAKD,IAAL,CAAaoG,KACtB/L,GAAa,GACbE,GAAc,IAohBF,SAII,cAAC,IAAD,MAEJ,wBACI2K,UAAU,iCACViB,QAAS,kBArhBN,SAAClL,IACL,IAAXA,IACAA,EAAQ+E,GAAOrB,OAAS,GAG5B,IAAIsH,EAAYjG,GAChBiG,EAAUM,OAAOtL,EAAO,GACxBgF,GAAU,YAAIgG,IACd5L,GAAa,GACbE,GAAc,GA4gBiBiM,EAAgB,IAFnC,SAII,cAAC,IAAD,SAGR,qBAAKf,GAAG,OAAOP,UAAU,uBAAzB,SACI,wBACIA,UAAU,2BACViB,QAAS,WACLxB,GAAgB,SAHxB,SAMI,cAAC,IAAD,CAAWO,UAAU,mBAG7B,qBAAKO,GAAG,OAAOP,UAAU,YAAzB,SACI,wBACIA,UAAU,2BACViB,QAAS,WACLxB,GAAgB,SAHxB,SAMI,cAAC,IAAD,gB,kFC3xBpB8B,EAAiBC,EAAQ,KAQ7B,SAASjC,EAAMkC,GACPjC,UACIA,QAAQD,MACRC,QAAQD,MAAMkC,GACPjC,QAAQO,KACfP,QAAQO,IAAI0B,IAKxB,IAAMC,EAAU,uBAChB,SAASC,EAAwBC,GAAgB,IAAX7B,EAAU,uDAAJ,GAElC8B,EAAO,YAAO9B,EAAI+B,SAASJ,IAC3BK,EAAmB,IAAIC,IACzBH,EAAQI,KAAI,SAAClK,EAAGmK,GACZ,IAAMC,EAASC,SAASrK,EAAE,IACpBsK,EAAOR,EAAQK,EAAM,GACrBpL,EAAMuL,EAAOA,EAAKtM,MAAQgK,EAAItG,OAEpC,MAAO,CAAC0I,EAAS,EADLpC,EAAIuC,UAAUvK,EAAEhC,MAAOe,QAI3C,OAAO8K,EACFW,MAAM,MACNN,KAAI,SAACO,EAAML,GACR,IAAMtC,EAAMkC,EAAiBU,IAAIN,GACjC,MAAM,GAAN,OAAUA,EAAS,EAAnB,aAAyBK,GAAzB,OAAgC3C,EAAG,kBAAcA,GAAQ,OAE5D6C,KAAK,MAkBd,SAASC,EAAWC,EAAIC,EAAcC,EAAYC,GAC9C,IAAMC,EAAQD,GAAqBxD,EAE7B0D,EAASL,EAAGM,aAAaJ,GAU/B,GAPAF,EAAGC,aAAaI,EAAQJ,GAGxBD,EAAGO,cAAcF,IAGAL,EAAGQ,mBAAmBH,EAAQL,EAAGS,gBACnC,CAEX,IAAMC,EAAYV,EAAGW,iBAAiBN,GAQtC,OAPAD,EAAM,2BAAD,OAC0BM,EAD1B,aACwC3B,EACrCkB,EACAS,KAGRV,EAAGY,aAAaP,GACT,KAGX,OAAOA,EAaX,SAASQ,EACLb,EACAc,EACAC,EACAC,EACAb,GAEA,IAAMC,EAAQD,GAAqBxD,EAC7BsE,EAAUjB,EAAGa,gBAiBnB,GAhBAC,EAAQI,SAAQ,SAAUb,GACtBL,EAAGmB,aAAaF,EAASZ,MAEzBU,GACAA,EAAYG,SAAQ,SAAUE,EAAQ9B,GAClCU,EAAGqB,mBACCJ,EACAD,EAAgBA,EAAc1B,GAAOA,EACrC8B,MAIZpB,EAAGsB,YAAYL,IAGAjB,EAAGuB,oBAAoBN,EAASjB,EAAGwB,aACrC,CAET,IAAMd,EAAYV,EAAGyB,kBAAkBR,GAiBvC,OAhBAb,EAAM,6BAAD,OAC4BM,EAD5B,aAC0CI,EACtCzB,KAAI,SAACgB,GACF,IAAMrB,EAAMD,EACRiB,EAAG0B,gBAAgBrB,IAEjBzG,EAAOoG,EAAGQ,mBAAmBH,EAAQL,EAAG2B,aAC9C,MAAM,GAAN,OAAUhD,EAAeiD,eACrB5B,EACApG,GAFJ,cAGOoF,MAEVc,KAAK,QAGdE,EAAG6B,cAAcZ,GACV,KAEX,OAAOA,EA+CX,IAAMa,EAAoB,CAAC,gBAAiB,mBA4G7BC,MAjDf,SACI/B,EACAgC,EACAjB,EACAC,EACAb,GAGA,IADA,IAAMW,EAAU,GACPmB,EAAK,EAAGA,EAAKD,EAAcnL,SAAUoL,EAC1CnB,EAAQ5F,KACJ6E,EACIC,EACAgC,EAAcC,GACdjC,EAAG8B,EAAkBG,IACrB9B,IAKZ,OAAOU,EACHb,EACAc,EACAC,EACAC,EACAb,IC9CO+B,EA/HQ,SAAC1J,EAAQ2J,GAC5B,GAAI3J,GAAUA,EAAO3B,OAAS,EAAG,CAE7B,IAAMmJ,EAAKmC,EAAOC,WAAW,UAG7BD,EAAOE,MAA6B,EAArBF,EAAOrE,YACtBqE,EAAOG,OAA+B,EAAtBH,EAAOpE,aAGvB,IAAMkD,EAAUc,EAAyB/B,EAAI,CApIzC,0RAeenJ,EAuHG2B,EAAO3B,OAtHzB,+IAMiBA,EANjB,8CAOqBA,EAPrB,0CAQiBA,EARjB,0CASiBA,EATjB,moDAoEYA,EApEZ,2xCA0HE0L,EAAY,CACdC,SAAUxC,EAAGyC,kBAAkBxB,EAAS,cACxCyB,WAAY1C,EAAG2C,mBAAmB1B,EAAS,gBAC3C2B,aAAc5C,EAAG2C,mBAAmB1B,EAAS,gBAC7C4B,SAAU7C,EAAG2C,mBAAmB1B,EAAS,YACzC6B,UAAW9C,EAAG2C,mBAAmB1B,EAAS,aAC1C8B,UAAW/C,EAAG2C,mBAAmB1B,EAAS,cAI1C+B,EAAiBhD,EAAGiD,eACxBjD,EAAGkD,WAAWlD,EAAGmD,aAAcH,GAI/B,IAAII,EAAY,CACL,EAAGjB,EAAOG,OACrBH,EAAOE,MAAO,EACdF,EAAOE,MAAOF,EAAOG,OACV,EAAG,EACdH,EAAOE,MAAO,EACH,EAAGF,EAAOG,QAGrBtC,EAAGqD,WACCrD,EAAGmD,aACH,IAAIG,aAAaF,GACjBpD,EAAGuD,aAIP,IAAIC,EAAMxD,EAAGyD,oBAEbzD,EAAG0D,gBAAgBF,GAEnBxD,EAAG2D,wBAAwBpB,EAAUC,UAErC,IACI5I,EAAOoG,EAAG4D,MAGVC,EAAS,EAEb7D,EAAG8D,oBACCvB,EAAUC,SAPH,EASP5I,GAPY,EACH,EASTiK,GDwHZ,SAAmC1B,EAAQ4B,GACvCA,EAAaA,GAAc,EAC3B,IAAM1B,EAASF,EAAOrH,YAAciJ,EAAc,EAC5CzB,EAAUH,EAAOpH,aAAegJ,EAAc,GAChD5B,EAAOE,QAAUA,GAASF,EAAOG,SAAWA,KAC5CH,EAAOE,MAAQA,EACfF,EAAOG,OAASA,GC1HhB0B,CAA0BhE,EAAGmC,QAC7BnC,EAAGiE,SAAS,EAAG,EAAGjE,EAAGmC,OAAOE,MAAOrC,EAAGmC,OAAOG,QAG7CtC,EAAGkE,WAAWjD,GAGd,IAAM2B,EAAepK,EAAO6G,KAAI,YAC5B,OAD4C,EAAbzH,UAI7BiL,EAAWrK,EAAO6G,KAAI,YACxB,MAAO,CAD+B,EAAXxL,EAAW,EAARC,MAG5BgP,EAAYtK,EAAO6G,KAAI,YAAiB,IAAdxH,EAAa,EAAbA,OAC5B,MAAO,CAACA,EAAO5C,IAAIQ,EAAI,IAAKoC,EAAO5C,IAAIS,EAAI,IAAKmC,EAAO5C,IAAIU,EAAI,QAE7DoN,EAAYvK,EAAO6G,KAAI,YAAiB,IAAdxH,EAAa,EAAbA,OAC5B,MAAO,CAACA,EAAO9B,IAAIC,EAAI,IAAK6B,EAAO9B,IAAIE,EAAG4B,EAAO9B,IAAIG,MAGzD8J,EAAGmE,WAAW5B,EAAUK,aAAcA,EAAawB,QACnDpE,EAAGqE,WAAW9B,EAAUM,SAAUA,EAASuB,QAC3CpE,EAAGsE,WAAW/B,EAAUO,UAAWA,EAAUsB,QAC7CpE,EAAGsE,WAAW/B,EAAUQ,UAAWA,EAAUqB,QAC7CpE,EAAGuE,UAAUhC,EAAUG,WAAYP,EAAOE,MAAOF,EAAOG,QAGxD,IAAIkC,EAAWxE,EAAGyE,UAClBZ,EAAS,EACT,IAAIa,EAAQtB,EAAUvM,OA9CX,EA+CXmJ,EAAG2E,WAAWH,EAAUX,EAAQa,GA/Md,IAAC7N,G,OClBvB+N,EAAS,IAAIlS,OAAOmS,OAAO,uBA0DhBC,IAxDA,SAAC,GAA0B,IAAxBnH,EAAuB,EAAvBA,GAAI7E,EAAmB,EAAnBA,aAClB,EAA4BzG,mBAASyG,GAArC,mBAAON,EAAP,KAAeuM,EAAf,KACA,EAAiB1S,mBAAS2S,iBAAO,OAA1B7C,EAAP,oBACM8C,EAAO,SAAPA,EAAQC,GACA/C,EAAO1I,QAAQ2I,WAAW,MAChC+C,aAAaD,EAAW,EAAG,GAC/BxS,OAAO0S,uBAAsB,kBAAMH,EAAKC,OAEtCG,EAAa,WACf,GAAKlD,EAAO1I,QAAQ2I,WAAW,UA4B3B1P,OAAO0S,uBAAsB,kBACzBlD,EAAe1J,EAAQ2J,EAAO1I,gBA7BI,CACtCmD,QAAQO,IAAI,oCACZ,IACM+H,EADI/C,EAAO1I,QAAQ2I,WAAW,MACdkD,gBAClBnD,EAAO1I,QAAQ4I,MACfF,EAAO1I,QAAQ6I,QAEfiD,EAAeL,EAAUM,KAAK3O,OAElC+N,EAAOa,aACPb,EAAS,IAAIlS,OAAOmS,OAAO,wBACpBa,YAAY,CACfR,UAAWA,EACX1M,OAAQA,EACR2J,OAAQ,CACJE,MAAOF,EAAO1I,QAAQ4I,MACtBC,OAAQH,EAAO1I,QAAQ6I,UAG/BsC,EAAOe,QAAU,SAAC1I,GACdL,QAAQO,IAAI,QAASF,IAEzB2H,EAAOgB,UAAY,SAAC5M,GACZuM,IAAiBvM,EAAEwM,KAAKN,UAAUM,KAAK3O,QACvCnE,OAAO0S,uBAAsB,kBAAMH,EAAKjM,EAAEwM,KAAKN,iBAoB/D,OAXAlI,qBAAU,WACN+H,EAAUjM,GACVuM,OAEJrI,qBAAU,WACDmF,EAAO1I,QAAQ2I,WAAW,WAC3ByD,MACI,0EAGT,IACI,wBAAQlI,GAAIA,EAAIY,IAAK4D,M,kFCpD1B2D,EAAQ,SAAC,GAAsD,IAAD,oBAC5DjO,EADSW,EAAmD,EAAnDA,OAAQwF,EAA2C,EAA3CA,cAAe7K,EAA4B,EAA5BA,MAAOiL,EAAqB,EAArBA,eAGvCvG,EADAW,EAAOrF,GAAO0E,OAAOtB,IACZiC,EAAOrF,GAAO0E,OAAOtB,IAErBiC,EAAOrF,GAAO0E,OAE3B,IAAMkO,EAASC,IAAS,CACpBC,QAAS,CACLC,UAAW,CACPC,KAAM3N,EAAOrF,GAAO4E,UAAUlE,EAC9BuS,IAAK5N,EAAOrF,GAAO4E,UAAUjE,GAEjCuS,eAAgB,CACZC,QAAS,OACTC,eAAgB,SAChBC,WAAY,SACZlE,OAAQ,OACRD,MAAO,OACPoE,SAAU,UAEdC,gBAAiB,CACbC,iBAAiB,UAAAnO,EAAOrF,GAAOqG,YAAd,eAAoBlG,YAC/BuE,EACA,aAEV+O,cAAe,CAAED,gBAAiB9O,GAClCD,OAAQ,CACJyK,OAAO,UAAA7J,EAAOrF,GAAOqG,YAAd,eAAoBlG,YACrB,EAAIkF,EAAOrF,GAAOyE,OAAS,GAAK,KAChC,MACN0K,QAAQ,UAAA9J,EAAOrF,GAAOqG,YAAd,eAAoBlG,YACtB,EAAIkF,EAAOrF,GAAOyE,OAAS,GAAK,KAChC,MACN6C,YAAY,UAAAjC,EAAOrF,GAAOqG,YAAd,eAAoBhG,UAApB,2CAC8B,IAD9B,aAEF,KAFE,qDAIgC,IAJhC,aAKF,KALE,SAQhBqT,aAAc,CACVxE,OAAO,UAAA7J,EAAOrF,GAAOqG,YAAd,eAAoBvG,SAAU,OAAY,MACjDqP,QAAQ,UAAA9J,EAAOrF,GAAOqG,YAAd,eAAoBvG,SAAU,OAAY,MAClD6T,UAAU,UAAAtO,EAAOrF,GAAOqG,YAAd,eAAoBvG,SAAU,OAAkB,MAC1D8T,WAAW,UAAAvO,EAAOrF,GAAOqG,YAAd,eAAoBvG,UACzB,UAAAuF,EAAOrF,GAAOqG,YAAd,eAAoBlG,YAApB,uCAEQkF,EAAOrF,GAAOyE,OAAS,GAF/B,iCAKA,wBACN6C,YAAY,UAAAjC,EAAOrF,GAAOqG,YAAd,eAAoBhG,UAApB,2CAC8B,IAD9B,aAEF,KAFE,+DAIgC,IAJhC,aAKF,KALE,kBAOZyK,MAAOpG,GAEXmP,UAAW,CACPxE,SAAU,QACVuE,UAAU,yCAAD,OACLvO,EAAOrF,GAAOyE,OAAS,GADlB,UAQrB,OAFAY,EAAOrF,GAAOuE,SAAWsN,mBACzBxM,EAAOrF,GAAOwE,aAAeqN,mBAEzB,sBACI5H,UAAU,iBACV1D,MAAOqM,EAAOG,UACd3H,IAAK/F,EAAOrF,GAAOwE,aAHvB,UAMI,qBAAK+B,MAAOqM,EAAOM,eAAnB,SACI,gCACI,qBACIjJ,UAAU,YACV1D,MAAOqM,EAAOc,aACdxI,QAAS,SAACrF,GAAD,OAAOoF,EAAejL,IAHnC,SAKI,cAAC,IAAD,MAEJ,qBACIuG,MAAOqM,EAAOnO,OACdwF,UAAU,cACVO,GAAInF,EAAOrF,GAAOwK,KAEtB,qBACIY,IAAK/F,EAAOrF,GAAOuE,SACnBgC,MAAOqM,EAAOW,gBACdtJ,UACI,YACC5E,EAAOrF,GAAOqG,OACdhB,EAAOrF,GAAOqG,KAAKjG,QAChBiF,EAAOrF,GAAOqG,KAAKvG,SACjB,UACA,IAEVgU,SAAU,EACVtJ,GAAInF,EAAOrF,GAAOwK,UAK7BnF,EAAOrF,GAAOqG,MAAQhB,EAAOrF,GAAOqG,KAAK1B,YACtC,cAAC,IAAD,CACI4B,MAAOqM,EAAOiB,UACd/I,MAAOpG,EACPqP,SAAU,SAACjJ,GAAD,OAAWD,EAAc7K,EAAO8K,GAAO,IACjDkJ,iBAAkB,SAAClJ,GAAD,OACdD,EAAc7K,EAAO8K,GAAO,IAEhCmJ,cAAc,EACdC,aAAc,SAMlCvB,EAAMwB,aAAe,CACjBlK,UAAW,YAGA0I,QCjHAyB,IAlBA,YAA0D,IAAvD/O,EAAsD,EAAtDA,OAAQwF,EAA8C,EAA9CA,cAAeJ,EAA+B,EAA/BA,SAAUQ,EAAqB,EAArBA,eAC/CpB,qBAAU,WACNY,OAEJ,IAAI2J,EAAS,GACb,IAAK,IAAI/Q,KAAKgC,EACV+O,EAAOrM,KACH,cAAC,EAAD,CACI1C,OAAQA,EACRrF,MAAOqD,EACPwH,cAAeA,EACfI,eAAgBA,KAI5B,OAAOmJ,I","file":"static/js/main.a1890bfa.chunk.js","sourcesContent":["const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport './css/style.css';\r\nimport './css/dragPalette.css';\r\nimport './css/pointManager.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\nimport { BrowserRouter as Router } from 'react-router-dom';\r\n\r\nReactDOM.render(\r\n    <React.StrictMode>\r\n        <Router>\r\n            <App />\r\n        </Router>\r\n    </React.StrictMode>,\r\n    document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n","import React, { useState, useEffect } from 'react';\r\nimport Points from './components/Points';\r\nimport Canvas from './components/Canvas';\r\nimport { FaPlus, FaMinus, FaUndoAlt, FaRedoAlt } from 'react-icons/fa';\r\nimport { BrowserRouter as Router, useLocation } from 'react-router-dom';\r\n\r\nfunction App() {\r\n    /**\r\n     * @type {boolean} Potential change in the system is stored here.\r\n     * Any function that changes the system changes this, and useEffect looks for this flagged to push to undo.\r\n     */\r\n    const [potChange, setPotChange] = useState(false);\r\n    const [renderPage, setRenderPage] = useState(false);\r\n    /**\r\n     * @type {window.location} The URL of the current window.\r\n     * Used to check for re-render requirement and prevent repeatitive pushState to the browser.\r\n     */\r\n    const [url, setUrl] = useState(window.location.origin);\r\n    const location = useLocation();\r\n    /** @type {object} Stores various mouse states */\r\n    const [mouse, setMouse] = useState({\r\n        /** @type {boolean} Is the mouse down or not? */\r\n        down: false,\r\n        /** @type {boolean} Not sure what went through my mind */\r\n        stateSaved: false,\r\n        /** @type {object} The clicked object */\r\n        clicked: {\r\n            /** @type {boolean} Is the mouse down or not? */\r\n            status: false,\r\n            /** @type {BigInteger} Index of the dragItem that is in clicked mode. */\r\n            index: undefined,\r\n            /** @type {React.MutableRefObject} Reference of the dragItem that is in clicked mode. */\r\n            obj: undefined,\r\n        },\r\n        /** @type {boolean} Is radius of some dragItem being shown or not? */\r\n        showRadius: false,\r\n        active: false,\r\n        /** @type {object} The resizing object */\r\n        resizing: {\r\n            /** @type {boolean} Is some dragItem being resized or not? */\r\n            mode: false,\r\n            /** @type {object} ?? The start point of the resize event. */\r\n            start: false,\r\n        },\r\n        /** @type {object} The mouse target object. */\r\n        target: {\r\n            /** @type {React.MutableRefObject} Reference of the target dragItem */\r\n            obj: undefined,\r\n            /** @type {BigInteger} Index of the dragItem that is targetted. */\r\n            index: undefined,\r\n            /** @type {object} ?? Initial position of the targetted dragItem before mouse events. */\r\n            initialPosition: {\r\n                x: 0,\r\n                y: 0,\r\n            },\r\n            /** @type {BigInteger} Initial radius of the dragItem that is targetted. */\r\n            initialRadius: undefined,\r\n        },\r\n        /** @type {object} The mouse positions object */\r\n        pos: {\r\n            /** @type {object} XY coordinates of the mouse at the start of mouse events. */\r\n            start: {\r\n                x: 0,\r\n                y: 0,\r\n            },\r\n            /** @type {object} XY coordinates of the mouse in the middle (admist) of mouse events. */\r\n            middle: {\r\n                x: 0,\r\n                y: 0,\r\n            },\r\n            /** @type {object} XY coordinates of the mouse at the end of mouse events. */\r\n            end: {\r\n                x: 0,\r\n                y: 0,\r\n            },\r\n            /** @type {object} Function to return the above coordinates as a [x, y] array. */\r\n            getXY: function (from) {\r\n                if (from === 'start') return [this.start.x, this.start.y];\r\n                else if (from === 'middle')\r\n                    return [this.middle.x, this.middle.y];\r\n                else if (from === 'end') return [this.end.x, this.end.y];\r\n            },\r\n        },\r\n    });\r\n    /**\r\n     * @type {Array} DOM stripped version of dragIs that can be pushed to undo redo stacks.\r\n     * Maintained to push to undo redo without hassle and for comparison before any push.\r\n     */\r\n    const [view, setView] = useState([]);\r\n    const [undo, setUndo] = useState([]);\r\n    const [redo, setRedo] = useState([]);\r\n    /**\r\n     * @type {boolean} Was an undo/redo button pressed recently?\r\n     */\r\n    const [undoRedo, setUndoRedo] = useState(false);\r\n    /**\r\n     * Function to convert colour object in RGB to HSL, HSV and Hex reperesentations.\r\n     *\r\n     * @param {object} rgb\r\n     * @return {{rgb:object, hsv:object, hsl:object, hex:object}} Various colour representations.\r\n     */\r\n    const rgbToHslHsvHex = (rgb) => {\r\n        var rgbArr = [rgb.r, rgb.g, rgb.b];\r\n        var M, m, C, hue, V, L, Sv, Sl;\r\n        M = Math.max(...rgbArr);\r\n        m = Math.min(...rgbArr);\r\n        C = M - m;\r\n        // I = (rgbArr[0] + rgbArr[1] + rgbArr[2]) / 3;\r\n        // Hue\r\n        if (C === 0) hue = 0;\r\n        else if (M === rgbArr[0]) hue = ((rgbArr[1] - rgbArr[2]) / C) % 6;\r\n        else if (M === rgbArr[1]) hue = (rgbArr[2] - rgbArr[0]) / C + 2;\r\n        else if (M === rgbArr[2]) hue = (rgbArr[0] - rgbArr[1]) / C + 4;\r\n        hue *= 60;\r\n        // Lightness and Value\r\n        V = M / 255;\r\n        L = (M + m) / (2 * 255);\r\n        // Saturation\r\n        if (V === 0) Sv = 0;\r\n        else Sv = C / (V * 255);\r\n        if (L === 1 || L === 0) Sl = 0;\r\n        else Sl = C / (255 * (1 - Math.abs(2 * L - 1)));\r\n\r\n        hue = ((hue % 360) + 360) % 360;\r\n        let hsv = { h: hue, s: Sv, v: V, a: 1 };\r\n        let hsl = { h: hue, s: Sl, l: L, a: 1 };\r\n        rgb.a = 1;\r\n        let hex = '#';\r\n        for (let i in rgbArr) {\r\n            let colorcode = Math.floor(rgbArr[i]).toString(16);\r\n            hex += '0'.repeat(2 - colorcode.length) + colorcode;\r\n        }\r\n        return { rgb: rgb, hsv: hsv, hsl: hsl, hex: hex };\r\n    };\r\n    /** @type {object} RGB colour object, the default colour at initialization */\r\n    var defaultColour = rgbToHslHsvHex({\r\n        r: Math.random() * 255,\r\n        g: Math.random() * 255,\r\n        b: Math.random() * 255,\r\n    });\r\n    var paramsHash = new URLSearchParams(window.location.search);\r\n    var params = {};\r\n    var initDragIs;\r\n    try {\r\n        for (var pair of paramsHash.entries()) {\r\n            params[pair[0]] = JSON.parse(\r\n                Buffer.from(pair[1], 'base64').toString()\r\n            );\r\n            // try {\r\n            //     params[pair[0]] = JSON.parse(pair[1]);\r\n            // } catch {\r\n            //     params[pair[0]] = pair[1]\r\n            // }\r\n        }\r\n        if ('points' in params) initDragIs = params['points'];\r\n        else throw new Error('force trip');\r\n    } catch {\r\n        initDragIs = [\r\n            {\r\n                /** @type {React.MutableRefObject} The reference to the `dragItem` DOM item. */\r\n                pointRef: null,\r\n                /** @type {React.MutableRefObject} The reference to the `dragIContainer` DOM item. */\r\n                containerRef: null,\r\n                /** @type {number} The radius of the colour point. */\r\n                radius: 0,\r\n                /** @type {{rgb:object, hsv:object, hsl:object, hex:string}} Various colour representations of the point. */\r\n                colour: defaultColour,\r\n                /** @type {boolean} tells React to show/hide the colour picker. */\r\n                showPicker: false,\r\n                /** @type {{x:number, y:number}} controls the location of the `dragIContainer`, relative to the `outerContainer`. */\r\n                currentXY: { x: 50, y: 50 },\r\n                /** @type {Array} The CSS size of `dragItem`. */\r\n                size: undefined,\r\n                /** @type {Array} The CSS size of `div` inside `dragIContainer`. */\r\n                containerSize: undefined,\r\n            },\r\n        ];\r\n    }\r\n    /**\r\n     * @type {Array} The functional array driving Points, Point, canvasPoints, view and everything else.\r\n     */\r\n    const [dragIs, setDragIs] = useState(initDragIs);\r\n    /**\r\n     * Function to convert multi-representation colour object to 2x3 array of RGB and HSV representations.\r\n     *\r\n     * @param {{rgb:object, hsv:object, [hsl:object, hex:object]}} obj\r\n     * @return {[Array, Array]} [[h, s, v], [r, g, b]].\r\n     */\r\n    const hsvRgbObjToArr = (obj) => {\r\n        var arr = [\r\n            [0, 0, 0],\r\n            [0, 0, 0],\r\n        ];\r\n        arr[0] = [obj.hsv.h, obj.hsv.s, obj.hsv.v];\r\n        arr[1] = [obj.rgb.r, obj.rgb.g, obj.rgb.b];\r\n        return arr;\r\n    };\r\n    /**\r\n     * Function to convert `DragIs[]` array to `canvasPoints[]` state that the renderer expects.\r\n     *\r\n     * @param {boolean} set Set the canvasPoints state or not?\r\n     * @return {{x, y, colour:object colourArr:Array, radius: number}[]} canvasPoints if not `set`.\r\n     */\r\n    const getCanvasPoints = (set) => {\r\n        let points = new Array(dragIs.length);\r\n        for (let i in dragIs) {\r\n            if (dragIs[i].size) {\r\n                let centre = pointCentre(i);\r\n                points[i] = {\r\n                    x: centre.x,\r\n                    y: centre.y,\r\n                    colour: dragIs[i].colour,\r\n                    colourArr: hsvRgbObjToArr(dragIs[i].colour),\r\n                    radius: dragIs[i].radius,\r\n                };\r\n            }\r\n        }\r\n        if (set) setCanvasPoints(points);\r\n        else return points;\r\n    };\r\n    const [canvasPoints, setCanvasPoints] = useState(false);\r\n    /**\r\n     * Function to add a new DragItem with random colour and position. The function sets the `dragIs[]` state and flags `potChange` at exit.\r\n     */\r\n    const addDragItem = () => {\r\n        var currentXY = { x: 50, y: 50 },\r\n            colour;\r\n        if (dragIs.length > 0) {\r\n            var boundXY = [\r\n                [0, 0],\r\n                [0, 0],\r\n            ];\r\n            boundXY[1] = [\r\n                boundXY[0][0] +\r\n                    dragIs[0].containerRef.current.parentNode.clientWidth -\r\n                    dragIs[0].size[0],\r\n                boundXY[0][1] +\r\n                    dragIs[0].containerRef.current.parentNode.clientHeight -\r\n                    dragIs[0].size[1],\r\n            ];\r\n            let x, y;\r\n            x = Math.floor(Math.random() * boundXY[1][0] + boundXY[0][0]);\r\n            y = Math.floor(Math.random() * boundXY[1][1] + boundXY[0][1]);\r\n            currentXY = { x: x, y: y };\r\n        }\r\n        colour = {\r\n            r: Math.random() * 255,\r\n            g: Math.random() * 255,\r\n            b: Math.random() * 255,\r\n        };\r\n        colour = rgbToHslHsvHex(colour);\r\n        const newDragItem = {\r\n            ref: null,\r\n            containerRef: null,\r\n            radius: 0,\r\n            colour: colour,\r\n            showPicker: false,\r\n            pointerOffset: { x: 0, y: 0 },\r\n            currentXY: currentXY,\r\n            size: undefined,\r\n            containerSize: undefined,\r\n        };\r\n        setDragIs([...dragIs, newDragItem]);\r\n        setPotChange(true);\r\n        setRenderPage(true);\r\n    };\r\n    /**\r\n     * Function to remove the DragItem of specified index. The function sets the `dragIs[]` state and flags `potChange` at exit.\r\n     *\r\n     * @param {number} index the index of the DragItem to be removed.\r\n     */\r\n    const removeDragItem = (index) => {\r\n        if (index === -1) {\r\n            index = dragIs.length - 1;\r\n        }\r\n        // console.log('Removing point with key ' + index);\r\n        let newDragIs = dragIs;\r\n        newDragIs.splice(index, 1);\r\n        setDragIs([...newDragIs]);\r\n        setPotChange(true);\r\n        setRenderPage(true);\r\n        // console.log('New points are ', dragIs);\r\n    };\r\n    /**\r\n     * Pointer down event handler that enables modification of DragItems.\r\n     *\r\n     * @param {MouseEvent} e The mouse event variable.\r\n     */\r\n    const dragStart = (e) => {\r\n        mouse.down = true; // pointer is down\r\n        mouse.pos.start = getPointerLocation(e); // getting pointer location\r\n\r\n        // acquire pointer target\r\n        mouse.target.obj = document.elementFromPoint(\r\n            ...mouse.pos.getXY('start')\r\n        );\r\n        // index of the target in the dragIs[] array\r\n        var index = getIndex(mouse.target.obj);\r\n        // console.log(index);\r\n        if (index) mouse.target.index = index;\r\n        else mouse.target.index = undefined;\r\n\r\n        // Unhide hideButtons that were hidden previously when target is not a dragItem\r\n        if (!mouse.target.obj.classList.contains('dragItem')) {\r\n            hideButton(false, 0, '0.3s');\r\n        }\r\n\r\n        // moving a point or making it clicked (highlighted)...\r\n        if (\r\n            // if pointerdown on the a dragItem and...\r\n            mouse.target.obj.classList.contains('dragItem') &&\r\n            (!mouse.clicked.status || // if none is clicked, ...\r\n            (mouse.clicked.status && // or clicked item is not pointerdown item...\r\n                mouse.clicked.index !== mouse.target.index) || // or radius is not being modified (or shown).\r\n                !mouse.showRadius)\r\n        ) {\r\n            if (index) {\r\n                // console.log('Going to move');\r\n                // this if is just to catch the error \"dragIs[index] is undefined\" that appears for some fucking reason.\r\n                // save the initial location of the target before it is moved.\r\n                mouse.target.init = {\r\n                    x:\r\n                        dragIs[mouse.target.index].currentXY.x -\r\n                        mouse.pos.start.x,\r\n                    y:\r\n                        dragIs[mouse.target.index].currentXY.y -\r\n                        mouse.pos.start.y,\r\n                };\r\n                mouse.active = true; // set mouse.active to indicate some point is starting to be moved (technically moved is set in drag where the mouse movement is checked to be isClick() or not).\r\n                // set mouse to be active and bring it to top in CSS.\r\n                dragIs[mouse.target.index].tags = { active: true };\r\n                dragIs[\r\n                    mouse.target.index\r\n                ].containerRef.current.style.zIndex = 2;\r\n            }\r\n        }\r\n        // start resizing the clicked (highlighted) point\r\n        else if (\r\n            mouse.clicked.status && // some item is clicked...\r\n            mouse.clicked.index === mouse.target.index && // and clicked item is pointerdown item...\r\n            dragIs[mouse.clicked.index]?.tags?.showRadius // and clicked item is in showRadius mode, not colour picker mode.\r\n        ) {\r\n            // console.log('Going to resize');\r\n            // console.log(mouse.clicked.obj, mouse.target.obj);\r\n            // console.log(mouse);\r\n            mouse.resizing.mode = true; // enable resizing mode, but not start it yet.\r\n            mouse.showRadius = true; // show it's radius\r\n            mouse.target.initialRadius = dragIs[mouse.clicked.index].radius; // set initial radius of the object\r\n        }\r\n        setDragIs([...dragIs]);\r\n        setRenderPage(true);\r\n        setMouse(mouse);\r\n    };\r\n    const drag = (e) => {\r\n        mouse.pos.middle = getPointerLocation(e);\r\n        // if an item is active and the mouse movement is not a click, drag it\r\n        if (mouse.active && !isClick(mouse.pos.start, mouse.pos.middle)) {\r\n            closePoint();\r\n            var index = mouse.target.index;\r\n            if (index) {\r\n                e.preventDefault();\r\n                hideButton(true, 0);\r\n                try {\r\n                    dragIs[index].containerRef.current.style.zIndex = 2; // bringing item to top\r\n                } catch {}\r\n                var currentXY = { x: 0, y: 0 }; // saving the position to a variable (used to bound...)\r\n                currentXY.x = mouse.pos.middle.x + mouse.target.init.x;\r\n                currentXY.y = mouse.pos.middle.y + mouse.target.init.y;\r\n                // finding the bounds of the dragPalette element\r\n                // this is done so that the points stay inside\r\n                // the palette even if cursor is outside\r\n                let boundXY = getBounds(index);\r\n                dragIs[index].currentXY.x = Math.max(\r\n                    Math.min(currentXY.x, boundXY[1][0]),\r\n                    boundXY[0][0]\r\n                );\r\n                dragIs[index].currentXY.y = Math.max(\r\n                    Math.min(currentXY.y, boundXY[1][1]),\r\n                    boundXY[0][1]\r\n                );\r\n            }\r\n        }\r\n        // resizing\r\n        else if (mouse.resizing.mode) {\r\n            if (mouse.clicked.index) {\r\n                let r = dist(pointCentre(mouse.clicked.index), {\r\n                    x: mouse.pos.middle.x - 20,\r\n                    y: mouse.pos.middle.y - 20,\r\n                });\r\n                if (mouse.resizing.start) {\r\n                    dragIs[mouse.clicked.index].radius = Math.max(\r\n                        Math.abs(r) - 25,\r\n                        0\r\n                    );\r\n                } else if (r - 25 >= mouse.target.initialRadius) {\r\n                    dragIs[mouse.clicked.index].tags\r\n                        ? (dragIs[mouse.clicked.index].tags.resizing = true)\r\n                        : (dragIs[mouse.clicked.index].tags = {\r\n                              resizing: true,\r\n                          });\r\n                    mouse.resizing.start = true;\r\n                }\r\n            }\r\n        } else if (mouse.down) {\r\n            dragStart(e);\r\n        }\r\n        setDragIs([...dragIs]);\r\n        if (mouse.down) {\r\n            // console.log(\"mouse is down\");\r\n            setRenderPage(true);\r\n        }\r\n        setMouse(mouse);\r\n    };\r\n    const dragEnd = (e) => {\r\n        // e.preventDefault();\r\n        if (e.type.substr(0, 5) === 'touch') {\r\n            mouse.pos.end = {\r\n                x: e.touches[0].clientX,\r\n                y: e.touches[0].clientY,\r\n            };\r\n        } else {\r\n            mouse.pos.end = { x: e.clientX, y: e.clientY };\r\n        }\r\n        let index = mouse.target.index;\r\n        if (index) {\r\n            let target = document.elementFromPoint(e.clientX, e.clientY);\r\n            // item is clicked, show radius\r\n            if (\r\n                isClick(mouse.pos.start, mouse.pos.end) &&\r\n                (target.classList.contains('dragItem') ||\r\n                    target.classList.contains('dragIWeight'))\r\n            ) {\r\n                try {\r\n                    dragIs[index].containerRef.current.style.zIndex = dragIs[\r\n                        index\r\n                    ].clicked\r\n                        ? 1\r\n                        : 2;\r\n                } catch {}\r\n                if (\r\n                    // Nothing is already clicked or something is already clicked and the new click target is different.\r\n                    !mouse.clicked.status ||\r\n                    (mouse.clicked.obj && mouse.clicked.obj !== target)\r\n                ) {\r\n                    mouse.clicked.status = true;\r\n                    mouse.clicked.obj = target;\r\n                    mouse.clicked.index = getIndex(target);\r\n                    closePoint(mouse.clicked.index);\r\n                    mouse.showRadius = true;\r\n                    try {\r\n                        dragIs[mouse.clicked.index].tags = {\r\n                            clicked: true,\r\n                            showRadius: true,\r\n                        };\r\n                    } catch {}\r\n                } else if (mouse.clicked.obj && mouse.clicked.obj === target) {\r\n                    mouse.clicked.status = false;\r\n                    closePoint();\r\n                    mouse.clicked.obj = undefined;\r\n                    mouse.clicked.index = undefined;\r\n                }\r\n            } else if (mouse.resizing.start) {\r\n                delete dragIs[index].tags.resizing;\r\n            } else if (mouse.active) {\r\n                hideButton(false);\r\n                closePoint();\r\n                mouse.active = false;\r\n                try {\r\n                    dragIs[index].containerRef.current.style.zIndex = 1;\r\n                } catch {}\r\n            }\r\n            mouse.down = false;\r\n            mouse.active = false;\r\n            mouse.resizing.mode = false;\r\n            mouse.resizing.start = false;\r\n            setDragIs([...dragIs]);\r\n            setMouse(mouse);\r\n        } else {\r\n            mouse.down = false;\r\n            setDragIs([...dragIs]);\r\n        }\r\n        setPotChange(true);\r\n        setRenderPage(true);\r\n    };\r\n    const getIndex = (obj) => {\r\n        for (let i in dragIs) {\r\n            if (dragIs[i].pointRef.current === obj) {\r\n                return i;\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    const getPointerLocation = (e) => {\r\n        let position = { x: undefined, y: undefined };\r\n        if (e.type.substr(0, 5) === 'touch') {\r\n            position = {\r\n                x: e.touches[0].clientX,\r\n                y: e.touches[0].clientY,\r\n            };\r\n        } else {\r\n            position = { x: e.clientX, y: e.clientY };\r\n        }\r\n        return position;\r\n    };\r\n    async function hideButton(state, timeout, animTime) {\r\n        if (!state && timeout === undefined) timeout = 700;\r\n        if (animTime === undefined) {\r\n            if (state) animTime = '0.15s';\r\n            else animTime = '1s';\r\n        }\r\n        setTimeout(() => {\r\n            let undoButton = document.getElementsByClassName('hideButton');\r\n            for (let k in undoButton) {\r\n                if (undoButton[k].classList)\r\n                    if (state) {\r\n                        undoButton[k].classList.add('hidden');\r\n                        undoButton[\r\n                            k\r\n                        ].style.transition = `all 0.5s cubic-bezier(0.39, 0.58, 0.57, 1), opacity ${animTime} ease-in-out`;\r\n                    } else {\r\n                        undoButton[k].classList.remove('hidden');\r\n                        undoButton[\r\n                            k\r\n                        ].style.transition = `all 0.5s cubic-bezier(0.39, 0.58, 0.57, 1), opacity ${animTime} ease-in-out`;\r\n                    }\r\n            }\r\n        }, timeout);\r\n    }\r\n    const pointCentre = (index) => {\r\n        let centre = {\r\n            x: dragIs[index].currentXY.x + dragIs[index].containerSize[0] / 2,\r\n            y: dragIs[index].currentXY.y + dragIs[index].containerSize[1] / 2,\r\n        };\r\n        return centre;\r\n    };\r\n    const getBounds = (index) => {\r\n        let boundXY = [\r\n            [\r\n                -(dragIs[index].containerSize[0] - dragIs[index].size[0]) / 2,\r\n                -(dragIs[index].containerSize[1] - dragIs[index].size[1]) / 2,\r\n            ], // min X, Y\r\n            [0, 0], // max X, Y\r\n        ];\r\n        boundXY[1] = [\r\n            boundXY[0][0] +\r\n                dragIs[index].containerRef.current.parentNode.clientWidth -\r\n                dragIs[index].size[0], // (- size) because anchor is at top left\r\n            boundXY[0][1] +\r\n                dragIs[index].containerRef.current.parentNode.clientHeight -\r\n                dragIs[index].size[1],\r\n        ];\r\n        return boundXY;\r\n    };\r\n    const closePoint = (index = undefined) => {\r\n        !index && (mouse.clicked.status = false);\r\n        for (let i in dragIs) {\r\n            if (index === i) {\r\n                continue;\r\n            }\r\n            if (dragIs[i].tags) delete dragIs[i].tags;\r\n            dragIs[i].containerRef.current.style.zIndex = 1;\r\n        }\r\n        setDragIs(dragIs);\r\n    };\r\n    const pushNewURL = ({ state = dragIs, push = true } = {}) => {\r\n        var url_query =\r\n            window.location.origin +\r\n            '/?points=' +\r\n            Buffer.from(JSON.stringify(removeDOMItems(state))).toString(\r\n                'base64'\r\n            );\r\n        // var url_query =\r\n        //     window.location.origin +\r\n        //     '/?points=' +\r\n        //     JSON.stringify(removeDOMItems(state));\r\n        // console.log('Pushing new URL');\r\n        // console.log({\r\n        //     'old URL': window.location.href,\r\n        //     'new URL': url_query,\r\n        //     'location state': location,\r\n        // });\r\n        if (window.location.href !== url_query) {\r\n            if (push) window.history.pushState(null, null, url_query);\r\n            else window.history.replaceState(null, null, url_query);\r\n            // } else {\r\n            // console.log('Same URL, ignoring push.');\r\n        }\r\n        setUrl(url_query);\r\n    };\r\n    const isReload = () => {\r\n        return (\r\n            (window.performance.navigation &&\r\n                window.performance.navigation.type === 1) ||\r\n            window.performance\r\n                .getEntriesByType('navigation')\r\n                .map((nav) => nav.type)\r\n                .includes('reload')\r\n        );\r\n    };\r\n    const dist = (p1, p2) => {\r\n        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n    };\r\n    const isClick = (startXY, endXY) => {\r\n        let tol = 5;\r\n        let value = dist(endXY, startXY);\r\n        return value <= tol;\r\n    };\r\n    const updateSizes = () => {\r\n        let update = false;\r\n        for (let i in dragIs) {\r\n            if (!dragIs[i].size) {\r\n                update = true;\r\n                dragIs[i].size = [\r\n                    dragIs[i].pointRef.current.offsetWidth,\r\n                    dragIs[i].pointRef.current.offsetHeight,\r\n                ];\r\n                dragIs[i].containerSize = [\r\n                    dragIs[i].pointRef.current.parentNode.parentNode\r\n                        .offsetWidth,\r\n                    dragIs[i].pointRef.current.parentNode.parentNode\r\n                        .offsetHeight,\r\n                ];\r\n            }\r\n        }\r\n        if (update) setDragIs(dragIs);\r\n    };\r\n    const onChangeColor = (index, color, finish = false) => {\r\n        let newDragIs = [...dragIs];\r\n        newDragIs[index].colour = color;\r\n        setDragIs([...newDragIs]);\r\n        setRenderPage(true);\r\n        if (finish) setPotChange(true);\r\n    };\r\n    const pushToView = (state, dontCopyToRedo = false) => {\r\n        if (dontCopyToRedo) {\r\n            let newView = copyDragIs(state);\r\n            setView(newView);\r\n        } else if (differentState(state, view)) {\r\n            setUndo([...undo, view]);\r\n            setRedo([]);\r\n            let newView = copyDragIs(state);\r\n            setView(newView);\r\n            pushNewURL(state);\r\n        }\r\n    };\r\n    const differentState = (newState, oldState) => {\r\n        let diff =\r\n            JSON.stringify(removeDOMItems(newState)) !=\r\n            JSON.stringify(removeDOMItems(oldState));\r\n        return (\r\n            JSON.stringify(removeDOMItems(newState)) !=\r\n            JSON.stringify(removeDOMItems(oldState))\r\n        );\r\n    };\r\n    const copyDragIs = (state) => {\r\n        let copyState = JSON.parse(JSON.stringify(removeDOMItems(state)));\r\n        return copyState;\r\n    };\r\n    const removeDOMItems = (state) => {\r\n        let minimalState = [];\r\n        for (let i in state) {\r\n            let item = { ...state[i] };\r\n            try {\r\n                item.pointRef = undefined;\r\n                item.containerRef = undefined;\r\n                delete item.tags;\r\n            } catch (error) {\r\n                console.error('Error in removing DOM elements.', error);\r\n            }\r\n            minimalState.push(item);\r\n        }\r\n        return minimalState;\r\n    };\r\n    const onPickerButton = (index) => {\r\n        if (dragIs[index].tags) {\r\n            if (dragIs[index].tags.showPicker) {\r\n                delete dragIs[index].tags.showPicker;\r\n                dragIs[index].tags.showRadius = true;\r\n                mouse.showRadius = true;\r\n            } else {\r\n                dragIs[index].tags.showPicker = true;\r\n                delete dragIs[index].tags.showRadius;\r\n                mouse.showRadius = false;\r\n            }\r\n        } else dragIs[index].tags = { showPicker: true };\r\n        setDragIs([...dragIs]);\r\n    };\r\n    const undoRedoClicked = (action) => {\r\n        if (action === 'undo' && undo.length) {\r\n            setRedo([...redo, view]);\r\n            setDragIs(undo[undo.length - 1]);\r\n            setUndo(undo.slice(0, undo.length - 1));\r\n            setUndoRedo(true);\r\n            setPotChange(true);\r\n            setRenderPage(true);\r\n        } else if (action === 'redo' && redo.length) {\r\n            setUndo([...undo, view]);\r\n            setDragIs(redo[redo.length - 1]);\r\n            setRedo(redo.slice(0, redo.length - 1));\r\n            setUndoRedo(true);\r\n            setPotChange(true);\r\n            setRenderPage(true);\r\n        }\r\n        mouse.down = false;\r\n        pushNewURL();\r\n    };\r\n    useEffect(() => {\r\n        if (renderPage) {\r\n            try {\r\n                getCanvasPoints(true);\r\n                setRenderPage(false);\r\n            } catch (err) {\r\n                console.error('Error in rendering page.', err);\r\n            }\r\n        }\r\n        if (potChange) {\r\n            pushToView(dragIs, undoRedo);\r\n            if (undoRedo) setUndoRedo(false);\r\n            setPotChange(false);\r\n        }\r\n    }, [renderPage]);\r\n    useEffect(() => {\r\n        var paramsHash = new URLSearchParams(window.location.search);\r\n        var params = {};\r\n        var reset = false;\r\n        try {\r\n            for (var pair of paramsHash.entries()) {\r\n                params[pair[0]] = JSON.parse(\r\n                    Buffer.from(pair[1], 'base64').toString()\r\n                );\r\n                // try {params[pair[0]] = JSON.parse(pair[1]);}\r\n                // catch {params[pair[0]] = pair[1];}\r\n            }\r\n            // console.log(params);\r\n            if (!('points' in params)) {\r\n                reset = true;\r\n                var defaultColour = rgbToHslHsvHex({\r\n                    r: Math.random() * 255,\r\n                    g: Math.random() * 255,\r\n                    b: Math.random() * 255,\r\n                });\r\n                params['points'] = [\r\n                    {\r\n                        pointRef: null,\r\n                        containerRef: null,\r\n                        radius: 0,\r\n                        colour: defaultColour,\r\n                        showPicker: false,\r\n                        currentXY: { x: 50, y: 50 },\r\n                        size: undefined,\r\n                        containerSize: undefined,\r\n                    },\r\n                ];\r\n            }\r\n            setDragIs([...params['points']]);\r\n            setUndo([...undo, view]);\r\n            setRedo([]);\r\n            let newView = copyDragIs(params['points']);\r\n            setView(newView);\r\n            setUndoRedo(true);\r\n            setPotChange(true);\r\n            setRenderPage(true);\r\n            pushNewURL({ push: reset });\r\n        } catch (error) {\r\n            console.log('Error occured while catching URL change: \\n', error);\r\n        }\r\n    }, [location]);\r\n    useEffect(() => {\r\n        getCanvasPoints(true);\r\n        setRenderPage(false);\r\n        pushToView(dragIs, true);\r\n        setPotChange(false);\r\n        hideButton(false, 500);\r\n        if (!('points' in params)) pushNewURL({ push: true });\r\n    }, []);\r\n    return (\r\n        <div\r\n            className=\"App\"\r\n            onPointerDown={(e) => dragStart(e)}\r\n            onPointerMove={(e) => drag(e)}\r\n            onPointerUp={(e) => dragEnd(e)}\r\n        >\r\n            <div id=\"outerContainer\">\r\n                <div id=\"dragPalette\">\r\n                    <Canvas\r\n                        id={'gradientPalette'}\r\n                        canvasPoints={canvasPoints}\r\n                    />\r\n                </div>\r\n                <Points\r\n                    points={dragIs}\r\n                    onRender={updateSizes}\r\n                    onChangeColor={onChangeColor}\r\n                    onPickerButton={onPickerButton}\r\n                />\r\n                <div id=\"point-manager\">\r\n                    <button\r\n                        className=\"button plus hideButton hidden\"\r\n                        onClick={addDragItem}\r\n                    >\r\n                        <FaPlus />\r\n                    </button>\r\n                    <button\r\n                        className=\"button minus hideButton hidden\"\r\n                        onClick={() => removeDragItem(-1)}\r\n                    >\r\n                        <FaMinus />\r\n                    </button>\r\n                </div>\r\n                <div id=\"undo\" className=\"undo-redo undoButton\">\r\n                    <button\r\n                        className=\"button hideButton hidden\"\r\n                        onClick={() => {\r\n                            undoRedoClicked('undo');\r\n                        }}\r\n                    >\r\n                        <FaUndoAlt className=\"undoButton\" />\r\n                    </button>\r\n                </div>\r\n                <div id=\"redo\" className=\"undo-redo\">\r\n                    <button\r\n                        className=\"button hideButton hidden\"\r\n                        onClick={() => {\r\n                            undoRedoClicked('redo');\r\n                        }}\r\n                    >\r\n                        <FaRedoAlt />\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default App;\r\n","/*\r\n * Copyright 2021, GFXFundamentals.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are\r\n * met:\r\n *\r\n *     * Redistributions of source code must retain the above copyright\r\n * notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above\r\n * copyright notice, this list of conditions and the following disclaimer\r\n * in the documentation and/or other materials provided with the\r\n * distribution.\r\n *     * Neither the name of GFXFundamentals. nor the names of his\r\n * contributors may be used to endorse or promote products derived from\r\n * this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nvar WebGLDebugUtil = require(\"webgl-debug\");\r\n\r\n/* global define */\r\n\r\n/**\r\n * Wrapped logging function.\r\n * @param {string} msg The message to log.\r\n */\r\nfunction error(msg) {\r\n    if (console) {\r\n        if (console.error) {\r\n            console.error(msg);\r\n        } else if (console.log) {\r\n            console.log(msg);\r\n        }\r\n    }\r\n}\r\n\r\nconst errorRE = /ERROR:\\s*\\d+:(\\d+)/gi;\r\nfunction addLineNumbersWithError(src, log = \"\") {\r\n    // Note: Error message formats are not defined by any spec so this may or may not work.\r\n    const matches = [...log.matchAll(errorRE)];\r\n    const lineNoToErrorMap = new Map(\r\n        matches.map((m, ndx) => {\r\n            const lineNo = parseInt(m[1]);\r\n            const next = matches[ndx + 1];\r\n            const end = next ? next.index : log.length;\r\n            const msg = log.substring(m.index, end);\r\n            return [lineNo - 1, msg];\r\n        })\r\n    );\r\n    return src\r\n        .split(\"\\n\")\r\n        .map((line, lineNo) => {\r\n            const err = lineNoToErrorMap.get(lineNo);\r\n            return `${lineNo + 1}: ${line}${err ? `\\n\\n^^^ ${err}` : \"\"}`;\r\n        })\r\n        .join(\"\\n\");\r\n}\r\n\r\n/**\r\n * Error Callback\r\n * @callback ErrorCallback\r\n * @param {string} msg error message.\r\n * @memberOf module:webgl-utils\r\n */\r\n\r\n/**\r\n * Loads a shader.\r\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\r\n * @param {string} shaderSource The shader source.\r\n * @param {number} shaderType The type of shader.\r\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\r\n * @return {WebGLShader} The created shader.\r\n */\r\nfunction loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\r\n    const errFn = opt_errorCallback || error;\r\n    // Create the shader object\r\n    const shader = gl.createShader(shaderType);\r\n\r\n    // Load the shader source\r\n    gl.shaderSource(shader, shaderSource);\r\n\r\n    // Compile the shader\r\n    gl.compileShader(shader);\r\n\r\n    // Check the compile status\r\n    const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n    if (!compiled) {\r\n        // Something went wrong during compilation; get the error\r\n        const lastError = gl.getShaderInfoLog(shader);\r\n        errFn(\r\n            `Error compiling shader: ${lastError}\\n${addLineNumbersWithError(\r\n                shaderSource,\r\n                lastError\r\n            )}`\r\n        );\r\n        gl.deleteShader(shader);\r\n        return null;\r\n    }\r\n\r\n    return shader;\r\n}\r\n\r\n/**\r\n * Creates a program, attaches shaders, binds attrib locations, links the\r\n * program and calls useProgram.\r\n * @param {WebGLShader[]} shaders The shaders to attach\r\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\r\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\r\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\r\n *        on error. If you want something else pass an callback. It's passed an error message.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction createProgram(\r\n    gl,\r\n    shaders,\r\n    opt_attribs,\r\n    opt_locations,\r\n    opt_errorCallback\r\n) {\r\n    const errFn = opt_errorCallback || error;\r\n    const program = gl.createProgram();\r\n    shaders.forEach(function (shader) {\r\n        gl.attachShader(program, shader);\r\n    });\r\n    if (opt_attribs) {\r\n        opt_attribs.forEach(function (attrib, ndx) {\r\n            gl.bindAttribLocation(\r\n                program,\r\n                opt_locations ? opt_locations[ndx] : ndx,\r\n                attrib\r\n            );\r\n        });\r\n    }\r\n    gl.linkProgram(program);\r\n\r\n    // Check the link status\r\n    const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n    if (!linked) {\r\n        // something went wrong with the link\r\n        const lastError = gl.getProgramInfoLog(program);\r\n        errFn(\r\n            `Error in program linking: ${lastError}\\n${shaders\r\n                .map((shader) => {\r\n                    const src = addLineNumbersWithError(\r\n                        gl.getShaderSource(shader)\r\n                    );\r\n                    const type = gl.getShaderParameter(shader, gl.SHADER_TYPE);\r\n                    return `${WebGLDebugUtil.glEnumToString(\r\n                        gl,\r\n                        type\r\n                    )}:\\n${src}`;\r\n                })\r\n                .join(\"\\n\")}`\r\n        );\r\n\r\n        gl.deleteProgram(program);\r\n        return null;\r\n    }\r\n    return program;\r\n}\r\n\r\n/**\r\n * Loads a shader from a script tag.\r\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\r\n * @param {string} scriptId The id of the script tag.\r\n * @param {number} opt_shaderType The type of shader. If not passed in it will\r\n *     be derived from the type of the script tag.\r\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\r\n * @return {WebGLShader} The created shader.\r\n */\r\nfunction createShaderFromScript(\r\n    gl,\r\n    scriptId,\r\n    opt_shaderType,\r\n    opt_errorCallback\r\n) {\r\n    let shaderSource = \"\";\r\n    let shaderType;\r\n    const shaderScript = document.getElementById(scriptId);\r\n    if (!shaderScript) {\r\n        throw \"*** Error: unknown script element\" + scriptId;\r\n    }\r\n    shaderSource = shaderScript.text;\r\n\r\n    if (!opt_shaderType) {\r\n        if (shaderScript.type === \"x-shader/x-vertex\") {\r\n            shaderType = gl.VERTEX_SHADER;\r\n        } else if (shaderScript.type === \"x-shader/x-fragment\") {\r\n            shaderType = gl.FRAGMENT_SHADER;\r\n        } else if (\r\n            shaderType !== gl.VERTEX_SHADER &&\r\n            shaderType !== gl.FRAGMENT_SHADER\r\n        ) {\r\n            throw \"*** Error: unknown shader type\";\r\n        }\r\n    }\r\n\r\n    return loadShader(\r\n        gl,\r\n        shaderSource,\r\n        opt_shaderType ? opt_shaderType : shaderType,\r\n        opt_errorCallback\r\n    );\r\n}\r\n\r\nconst defaultShaderType = [\"VERTEX_SHADER\", \"FRAGMENT_SHADER\"];\r\n\r\n/**\r\n * Creates a program from 2 script tags.\r\n *\r\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext\r\n *        to use.\r\n * @param {string[]} shaderScriptIds Array of ids of the script\r\n *        tags for the shaders. The first is assumed to be the\r\n *        vertex shader, the second the fragment shader.\r\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\r\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\r\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\r\n *        on error. If you want something else pass an callback. It's passed an error message.\r\n * @return {WebGLProgram} The created program.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction createProgramFromScripts(\r\n    gl,\r\n    shaderScriptIds,\r\n    opt_attribs,\r\n    opt_locations,\r\n    opt_errorCallback\r\n) {\r\n    const shaders = [];\r\n    for (let ii = 0; ii < shaderScriptIds.length; ++ii) {\r\n        shaders.push(\r\n            createShaderFromScript(\r\n                gl,\r\n                shaderScriptIds[ii],\r\n                gl[defaultShaderType[ii]],\r\n                opt_errorCallback\r\n            )\r\n        );\r\n    }\r\n    return createProgram(\r\n        gl,\r\n        shaders,\r\n        opt_attribs,\r\n        opt_locations,\r\n        opt_errorCallback\r\n    );\r\n}\r\n\r\n/**\r\n * Creates a program from 2 sources.\r\n *\r\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext\r\n *        to use.\r\n * @param {string[]} shaderSourcess Array of sources for the\r\n *        shaders. The first is assumed to be the vertex shader,\r\n *        the second the fragment shader.\r\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\r\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\r\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\r\n *        on error. If you want something else pass an callback. It's passed an error message.\r\n * @return {WebGLProgram} The created program.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction createProgramFromSources(\r\n    gl,\r\n    shaderSources,\r\n    opt_attribs,\r\n    opt_locations,\r\n    opt_errorCallback\r\n) {\r\n    const shaders = [];\r\n    for (let ii = 0; ii < shaderSources.length; ++ii) {\r\n        shaders.push(\r\n            loadShader(\r\n                gl,\r\n                shaderSources[ii],\r\n                gl[defaultShaderType[ii]],\r\n                opt_errorCallback\r\n            )\r\n        );\r\n    }\r\n    // console.log({ shaderSources, shaders });\r\n    return createProgram(\r\n        gl,\r\n        shaders,\r\n        opt_attribs,\r\n        opt_locations,\r\n        opt_errorCallback\r\n    );\r\n}\r\n\r\n/**\r\n * Resize a canvas to match the size its displayed.\r\n * @param {HTMLCanvasElement} canvas The canvas to resize.\r\n * @param {number} [multiplier] amount to multiply by.\r\n *    Pass in window.devicePixelRatio for native pixels.\r\n * @return {boolean} true if the canvas was resized.\r\n * @memberOf module:webgl-utils\r\n */\r\nfunction resizeCanvasToDisplaySize(canvas, multiplier) {\r\n    multiplier = multiplier || 1;\r\n    const width = (canvas.clientWidth * multiplier) | 0;\r\n    const height = (canvas.clientHeight * multiplier) | 0;\r\n    if (canvas.width !== width || canvas.height !== height) {\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport { resizeCanvasToDisplaySize };\r\nexport default createProgramFromSources;\r\n","// importing boilerplate functions\r\nimport createProgramFromSources, {\r\n    resizeCanvasToDisplaySize,\r\n} from \"../js/webglUtils\";\r\n// vertex shader function that is just a function to accompany the fragment shader\r\nconst getVertexShader = () => {\r\n    const vs = `#version 300 es\r\n    in vec2 a_position;\r\n\r\n    uniform vec2 u_resolution;\r\n\r\n    out vec2 v_position;\r\n\r\n    void main(){\r\n        gl_Position = vec4(a_position/u_resolution * 2.0 - 1.0, 0, 1);\r\n        v_position = vec2(a_position.x, u_resolution.y-a_position.y);\r\n    }\r\n    `;\r\n    return vs;\r\n};\r\n// fragment shader function that returns FS with the number of points embedded in the source (length)\r\nconst getFragmentShader = (length) => {\r\n    const fs = `#version 300 es\r\n    precision highp float;\r\n\r\n    in vec2 v_position;\r\n\r\n    uniform vec2 u_resolution;\r\n    uniform ivec2 pointsXY[${length}];\r\n    uniform float pointsRadius[${length}];\r\n    uniform vec3 pointsRGB[${length}];\r\n    uniform vec3 pointsHSV[${length}];\r\n\r\n    out vec4 outColor;\r\n\r\n    vec2 minMax(vec3 rgb){\r\n        vec2 mM = vec2(rgb[0], rgb[0]);\r\n        for(int i=1;i<3;i++){\r\n            if (rgb[i] < mM[0])\r\n                mM[0] = rgb[i];\r\n            if (rgb[i] > mM[1])\r\n                mM[1] = rgb[i];\r\n        }\r\n        return mM;\r\n    }\r\n\r\n    vec3 rgbToHsv(vec3 rgb){\r\n        float hue=0.0, C, V, Sv;\r\n        vec2 mM = minMax(rgb);\r\n        C = mM[1] - mM[0];\r\n        if(C==0.0){\r\n        }else if(mM[1]==rgb[0]){\r\n            hue = mod((rgb[1] - rgb[2]) / C, 6.0);\r\n        }else if(mM[1]==rgb[1]){\r\n            hue =     (rgb[2] - rgb[0]) / C + 2.0;\r\n        }else if(mM[1]==rgb[2]){\r\n            hue =     (rgb[0] - rgb[1]) / C + 4.0;\r\n        }\r\n        hue = mod((mod(hue * 60.0, 360.0) + 360.0), 360.0);\r\n\r\n        \r\n        V = mM[1];\r\n        if(V==0.0) Sv = 0.0;\r\n        else Sv = C/(V);\r\n\r\n        return vec3(hue, Sv, V);\r\n    }\r\n\r\n    float f(int n, vec3 hsv){\r\n        float k;\r\n        k = mod((float(n) + hsv[0] / 60.0), 6.0);\r\n        float fOut=hsv[2] - hsv[2] * hsv[1] * max(0.0, min(min(k, 4.0 - k), 1.0));\r\n        return fOut;\r\n    }\r\n\r\n    vec3 hsvToRgb(vec3 hsv){\r\n        vec3 rgb = vec3(f(5,hsv), f(3,hsv), f(1,hsv));\r\n        return rgb;\r\n    }\r\n\r\n    float dist(ivec2 pos, ivec2 point){\r\n        return pow(pow(float(pos.x-point.x), 2.0)+pow(float(pos.y-point.y), 2.0), 0.5);\r\n    }\r\n\r\n    void main(){\r\n        // ivec2 position = ivec2((v_position + 1.0) / 2.0 * u_resolution);\r\n        ivec2 position = ivec2(v_position);\r\n        float invSum = 0.0;\r\n        vec3 hsv = vec3(0,0,0), rgb = vec3(0,0,0);\r\n        int pointCentre = -1;\r\n        for(int i=0;i<${length};i++){\r\n            float d = dist(pointsXY[i], position);\r\n            if(abs(d)>0.0000001){\r\n                float invD = pow((1.0+pointsRadius[i]/10.0)/d, 3.0);\r\n                hsv += invD * pointsHSV[i];\r\n                rgb += invD * pointsRGB[i];\r\n                invSum += invD;\r\n            }else{\r\n                pointCentre=i;\r\n            }\r\n        }\r\n        if(pointCentre == -1){\r\n            hsv = hsv/invSum;\r\n            rgb = rgb/invSum;\r\n            // outColor = vec4(rgb, 1);\r\n            vec3 rgbInHsv = rgbToHsv(rgb);\r\n            // outColor = vec4(rgb, 1);\r\n            hsv[0] = rgbInHsv[0];\r\n            // hsv[1] = (1.25*rgbInHsv[1]+0.75*hsv[1])/2.0;\r\n            // hsv[1] = (2.0*rgbInHsv[1]+0.0*hsv[1])/2.0;\r\n            hsv[1] = rgbInHsv[1];\r\n            hsv[2] = (1.75*rgbInHsv[2]+0.25*hsv[2])/2.0;\r\n            // hsv[2]=0.5;\r\n            outColor = vec4(hsvToRgb(hsv),1);\r\n            // outColor = vec4(rgb,1);\r\n            // outColor = vec4(hsv,1);\r\n            // outColor = vec4(hsv[0]/360.0, hsv[1], hsv[2], 1);\r\n            // outColor = vec4(rgbInHsv[0]/360.0, rgbInHsv[1], rgbInHsv[2], 1);\r\n        }else{\r\n            hsv = pointsHSV[pointCentre];\r\n            rgb = pointsRGB[pointCentre];\r\n            outColor = vec4(rgb, 1);\r\n        }\r\n    }\r\n\r\n    `;\r\n    return fs;\r\n};\r\nconst renderGradient = (points, canvas) => {\r\n    if (points && points.length > 0) {\r\n        // accessing WebGL2 context from canvas\r\n        const gl = canvas.getContext(\"webgl2\");\r\n\r\n        // resizing canvas context to canvas width set by CSS\r\n        canvas.width = canvas.offsetWidth * 1;\r\n        canvas.height = canvas.offsetHeight * 1;\r\n\r\n        // creating program using the vs and fs functions above\r\n        const program = createProgramFromSources(gl, [\r\n            getVertexShader(),\r\n            getFragmentShader(points.length),\r\n        ]);\r\n\r\n        // storing locations of attributes and uniforms (state variables)\r\n        const locations = {\r\n            position: gl.getAttribLocation(program, \"a_position\"),\r\n            resolution: gl.getUniformLocation(program, \"u_resolution\"),\r\n            pointsRadius: gl.getUniformLocation(program, \"pointsRadius\"),\r\n            pointsXY: gl.getUniformLocation(program, \"pointsXY\"),\r\n            pointsRGB: gl.getUniformLocation(program, \"pointsRGB\"),\r\n            pointsHSV: gl.getUniformLocation(program, \"pointsHSV\"),\r\n        };\r\n\r\n        // creating a position buffer to load the entire clipspace into webgl buffer\r\n        var positionBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n        // clipspace is formed using two (anticlockwise) triangles\r\n        // prettier-ignore\r\n        var positions = [\r\n                   0, canvas.height, \r\n        canvas.width, 0, \r\n        canvas.width, canvas.height, \r\n                   0, 0, \r\n        canvas.width, 0, \r\n                   0, canvas.height\r\n    ];\r\n        // loading positions array to graphics buffer\r\n        gl.bufferData(\r\n            gl.ARRAY_BUFFER,\r\n            new Float32Array(positions),\r\n            gl.STATIC_DRAW\r\n        );\r\n\r\n        // creating vertex array object that will attach the positionBuffer to the attributes\r\n        var vao = gl.createVertexArray();\r\n        // binding current vertex array to vao\r\n        gl.bindVertexArray(vao);\r\n        // connecting vao to a_position attribute\r\n        gl.enableVertexAttribArray(locations.position);\r\n        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n        var size = 2; // 2 components per iteration (x, y)\r\n        var type = gl.FLOAT; // the data is 32bit floats\r\n        var normalize = false; // don't normalize the data\r\n        var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position (consecutive elemets)\r\n        var offset = 0; // start at the beginning of the buffer\r\n        // attach vao to the current ARRAY_BUFFER (positionBuffer) and pass instructions on how to interpret the data\r\n        gl.vertexAttribPointer(\r\n            locations.position,\r\n            size,\r\n            type,\r\n            normalize,\r\n            stride,\r\n            offset\r\n        );\r\n\r\n        // resizing canvas to fit the fill clipspace - not sure why since we already did canvas.width = offsetWidth and all...\r\n        resizeCanvasToDisplaySize(gl.canvas);\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n        // Telling WebGL to use our program (with the pair of shaders)\r\n        gl.useProgram(program);\r\n\r\n        // generating arrays that will be sent to uniforms\r\n        const pointsRadius = points.map(({ radius }) => {\r\n            return radius;\r\n        });\r\n        // console.log(pointsRadius.flat());\r\n        const pointsXY = points.map(({ x, y }) => {\r\n            return [x, y];\r\n        });\r\n        const pointsRGB = points.map(({ colour }) => {\r\n            return [colour.rgb.r / 255, colour.rgb.g / 255, colour.rgb.b / 255];\r\n        });\r\n        const pointsHSV = points.map(({ colour }) => {\r\n            return [colour.hsv.h / 360, colour.hsv.s, colour.hsv.v];\r\n        });\r\n        // setting uniforms\r\n        gl.uniform1fv(locations.pointsRadius, pointsRadius.flat());\r\n        gl.uniform2iv(locations.pointsXY, pointsXY.flat());\r\n        gl.uniform3fv(locations.pointsRGB, pointsRGB.flat());\r\n        gl.uniform3fv(locations.pointsHSV, pointsHSV.flat());\r\n        gl.uniform2f(locations.resolution, canvas.width, canvas.height);\r\n\r\n        // drawwwww\r\n        var primType = gl.TRIANGLES;\r\n        offset = 0;\r\n        var count = positions.length / size;\r\n        gl.drawArrays(primType, offset, count);\r\n        // requestAnimationFrame(renderGradient);\r\n\r\n        // // simply reading the data\r\n        // var results = new Uint8Array(canvas.width * canvas.height * 4);\r\n        // gl.readPixels(\r\n        //     0,\r\n        //     0,\r\n        //     canvas.width,\r\n        //     canvas.height,\r\n        //     gl.RGBA,\r\n        //     gl.UNSIGNED_BYTE,\r\n        //     results\r\n        // );\r\n        // var resultsB = [];\r\n        // // for (let i = 0; i < canvas.width * canvas.height; i++) {\r\n        // //     resultsB.push({\r\n        // //         r: results[4 * i],\r\n        // //         g: results[4 * i + 1],\r\n        // //         b: results[4 * i + 2],\r\n        // //         a: results[4 * i + 3],\r\n        // //     });\r\n        // // }\r\n        // console.log(results.slice(0, 4));\r\n    }\r\n};\r\n\r\nexport default renderGradient;\r\n","import React, { useState, useRef, useEffect } from \"react\";\r\nimport renderGradient from \"../js/gradientRenderer\";\r\n\r\nvar worker = new window.Worker(\"./gradientWorker.js\");\r\n\r\nconst Canvas = ({ id, canvasPoints }) => {\r\n    const [points, setPoints] = useState(canvasPoints);\r\n    const [canvas] = useState(useRef(null));\r\n    const draw = (imageData) => {\r\n        var ctx = canvas.current.getContext(\"2d\");\r\n        ctx.putImageData(imageData, 0, 0);\r\n        window.requestAnimationFrame(() => draw(imageData));\r\n    };\r\n    const shootPixel = () => {\r\n        if (!canvas.current.getContext(\"webgl2\")) {\r\n            console.log(\"WebGL2 not available, using CPU.\");\r\n            var ctx = canvas.current.getContext(\"2d\");\r\n            const imageData = ctx.createImageData(\r\n                canvas.current.width,\r\n                canvas.current.height\r\n            );\r\n            var imDataLength = imageData.data.length;\r\n            // Calling worker\r\n            worker.terminate();\r\n            worker = new window.Worker(\"./gradientWorker.js\");\r\n            worker.postMessage({\r\n                imageData: imageData,\r\n                points: points,\r\n                canvas: {\r\n                    width: canvas.current.width,\r\n                    height: canvas.current.height,\r\n                },\r\n            });\r\n            worker.onerror = (err) => {\r\n                console.log(\"error\", err);\r\n            };\r\n            worker.onmessage = (e) => {\r\n                if (imDataLength === e.data.imageData.data.length) {\r\n                    window.requestAnimationFrame(() => draw(e.data.imageData));\r\n                }\r\n            };\r\n        } else {\r\n            window.requestAnimationFrame(() =>\r\n                renderGradient(points, canvas.current)\r\n            );\r\n        }\r\n    };\r\n    useEffect(() => {\r\n        setPoints(canvasPoints);\r\n        shootPixel();\r\n    });\r\n    useEffect(() => {\r\n        if (!canvas.current.getContext(\"webgl2\")) {\r\n            alert(\r\n                \"WebGL not available in this browser/platform. Renders may be slower.\"\r\n            );\r\n        }\r\n    }, []);\r\n    return <canvas id={id} ref={canvas} />;\r\n};\r\n\r\nexport default Canvas;\r\n","import React from \"react\";\r\nimport reactCSS from \"reactcss\";\r\nimport { useRef } from \"react\";\r\nimport { SketchPicker } from \"react-color\";\r\nimport { FaTint } from \"react-icons/fa\";\r\n\r\nconst Point = ({ points, onChangeColor, index, onPickerButton }) => {\r\n    var colour;\r\n    if (points[index].colour.hex) {\r\n        colour = points[index].colour.hex;\r\n    } else {\r\n        colour = points[index].colour;\r\n    }\r\n    const styles = reactCSS({\r\n        default: {\r\n            container: {\r\n                left: points[index].currentXY.x,\r\n                top: points[index].currentXY.y,\r\n            },\r\n            pointContainer: {\r\n                display: \"flex\",\r\n                justifyContent: \"center\",\r\n                alignItems: \"center\",\r\n                height: \"36px\",\r\n                width: \"36px\",\r\n                flexWrap: \"nowrap\",\r\n            },\r\n            point_unclicked: {\r\n                backgroundColor: points[index].tags?.showRadius\r\n                    ? colour\r\n                    : \"#FFFFFF00\",\r\n            },\r\n            point_clicked: { backgroundColor: colour },\r\n            radius: {\r\n                width: points[index].tags?.showRadius\r\n                    ? 2 * points[index].radius + 50 + \"px\"\r\n                    : \"0px\",\r\n                height: points[index].tags?.showRadius\r\n                    ? 2 * points[index].radius + 50 + \"px\"\r\n                    : \"0px\",\r\n                transition: points[index].tags?.resizing\r\n                    ? `all 0s cubic-bezier(0.52, -1.01, ${1 - 0.52}, ${\r\n                          1 + 1.01\r\n                      }) 0s`\r\n                    : `all 0.3s cubic-bezier(0.52, -1.01, ${1 - 0.52}, ${\r\n                          1 + 1.01\r\n                      }) 0s`,\r\n            },\r\n            pickerButton: {\r\n                width: points[index].tags?.clicked ? 30 + \"px\" : \"0px\",\r\n                height: points[index].tags?.clicked ? 30 + \"px\" : \"0px\",\r\n                fontSize: points[index].tags?.clicked ? 30 / 2.5 + \"pt\" : \"0pt\",\r\n                transform: points[index].tags?.clicked\r\n                    ? points[index].tags?.showRadius\r\n                        ? `translate(-50%, calc(-40px - ${\r\n                              points[index].radius + 25\r\n                          }px))`\r\n                        : `translate(-50%, -60px)`\r\n                    : \"translate(-50%, -50%)\",\r\n                transition: points[index].tags?.resizing\r\n                    ? `all 0s cubic-bezier(0.52, -1.01, ${1 - 0.52}, ${\r\n                          1 + 1.01\r\n                      }) 0s, color 0s`\r\n                    : `all 0.3s cubic-bezier(0.52, -1.01, ${1 - 0.52}, ${\r\n                          1 + 1.01\r\n                      }) 0s, color 0s`,\r\n                color: colour,\r\n            },\r\n            pickerBar: {\r\n                position: \"fixed\",\r\n                transform: `translate(calc(-50% + 18px), calc(2px+${\r\n                    points[index].radius + 25\r\n                }))`,\r\n            },\r\n        },\r\n    });\r\n    points[index].pointRef = useRef();\r\n    points[index].containerRef = useRef();\r\n    return (\r\n        <div\r\n            className=\"dragIContainer\"\r\n            style={styles.container}\r\n            ref={points[index].containerRef}\r\n        >\r\n            {/* point container */}\r\n            <div style={styles.pointContainer}>\r\n                <div>\r\n                    <div\r\n                        className=\"dragColor\"\r\n                        style={styles.pickerButton}\r\n                        onClick={(e) => onPickerButton(index)}\r\n                    >\r\n                        <FaTint />\r\n                    </div>\r\n                    <div\r\n                        style={styles.radius}\r\n                        className=\"dragIWeight\"\r\n                        id={points[index].id}\r\n                    />\r\n                    <div\r\n                        ref={points[index].pointRef}\r\n                        style={styles.point_unclicked}\r\n                        className={\r\n                            \"dragItem\" +\r\n                            (points[index].tags &&\r\n                            (points[index].tags.active ||\r\n                                points[index].tags.clicked)\r\n                                ? \" active\"\r\n                                : \"\")\r\n                        }\r\n                        tabIndex={1}\r\n                        id={points[index].id}\r\n                    />\r\n                </div>\r\n            </div>\r\n            {/* Color picker */}\r\n            {points[index].tags && points[index].tags.showPicker && (\r\n                <SketchPicker\r\n                    style={styles.pickerBar}\r\n                    color={colour}\r\n                    onChange={(color) => onChangeColor(index, color, false)}\r\n                    onChangeComplete={(color) =>\r\n                        onChangeColor(index, color, true)\r\n                    }\r\n                    disableAlpha={true}\r\n                    presetColors={[]}\r\n                />\r\n            )}\r\n        </div>\r\n    );\r\n};\r\nPoint.defaultProps = {\r\n    className: \"dragItem\",\r\n};\r\n\r\nexport default Point;\r\n","import React from \"react\";\r\nimport Point from \"./Point\";\r\nimport { useEffect } from \"react\";\r\n\r\nconst Points = ({ points, onChangeColor, onRender, onPickerButton }) => {\r\n    useEffect(() => {\r\n        onRender();\r\n    });\r\n    var Points = [];\r\n    for (let i in points) {\r\n        Points.push(\r\n            <Point\r\n                points={points}\r\n                index={i}\r\n                onChangeColor={onChangeColor}\r\n                onPickerButton={onPickerButton}\r\n            />\r\n        );\r\n    }\r\n    return Points;\r\n};\r\n\r\nexport default Points;\r\n"],"sourceRoot":""}